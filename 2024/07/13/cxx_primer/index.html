<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lpdink.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本笔记是C++ Primer的阅读笔记，以知识点的形式呈现。primer很长很长，所以本笔记也很长很长…">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer笔记">
<meta property="og:url" content="https://lpdink.github.io/2024/07/13/cxx_primer/index.html">
<meta property="og:site_name" content="lpdink的博客">
<meta property="og:description" content="本笔记是C++ Primer的阅读笔记，以知识点的形式呈现。primer很长很长，所以本笔记也很长很长…">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-13T10:22:21.396Z">
<meta property="article:modified_time" content="2023-06-03T08:29:37.000Z">
<meta property="article:author" content="lpdink">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lpdink.github.io/2024/07/13/cxx_primer/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lpdink.github.io/2024/07/13/cxx_primer/","path":"2024/07/13/cxx_primer/","title":"C++ Primer笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ Primer笔记 | lpdink的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">lpdink的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">来点好玩的！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">15</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">14</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%A7%8B"><span class="nav-number">1.</span> <span class="nav-text">第一章 开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cerr%E4%B8%8Eclog"><span class="nav-number">1.1.</span> <span class="nav-text">cerr与clog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%85using%E5%BF%85%E9%A1%BB%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.2.</span> <span class="nav-text">仅using必须的项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-i%E8%80%8C%E4%B8%8D%E6%98%AFi"><span class="nav-number">1.3.</span> <span class="nav-text">使用++i而不是i++</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E2%85%A0%E9%83%A8%E5%88%86%EF%BC%9AC-%E5%9F%BA%E7%A1%80"><span class="nav-number"></span> <span class="nav-text">第Ⅰ部分：C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">第二章 变量和基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%95%BF%E5%BA%A6"><span class="nav-number">1.1.</span> <span class="nav-text">内置类型与长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AD%A6%E6%83%95unsigned"><span class="nav-number">1.2.</span> <span class="nav-text">警惕unsigned</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E4%BE%9D%E8%B5%96%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.</span> <span class="nav-text">不要依赖隐式转换和错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E6%AF%94%E2%80%99%E9%95%BF%E4%B8%80%E4%BD%8D"><span class="nav-number">1.4.</span> <span class="nav-text">“比’长一位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E4%B8%8E%E5%90%8E%E7%BC%80"><span class="nav-number">1.5.</span> <span class="nav-text">前缀与后缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8extern"><span class="nav-number">1.6.</span> <span class="nav-text">使用extern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="nav-number">1.7.</span> <span class="nav-text">extern “C”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">1.8.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.9.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8nullptr%EF%BC%8C%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8NULL"><span class="nav-number">1.10.</span> <span class="nav-text">使用nullptr，不再使用NULL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-%E6%8C%87%E9%92%88"><span class="nav-number">1.11.</span> <span class="nav-text">void*指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E4%BA%8Evar%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFtype"><span class="nav-number">1.12.</span> <span class="nav-text">*属于var，而不是type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E6%8C%87%E9%92%88"><span class="nav-number">1.13.</span> <span class="nav-text">高阶指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">1.14.</span> <span class="nav-text">创建指针的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-number">1.15.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.16.</span> <span class="nav-text">constexpr常量表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef"><span class="nav-number">1.17.</span> <span class="nav-text">typedef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto"><span class="nav-number">1.18.</span> <span class="nav-text">auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype"><span class="nav-number">1.19.</span> <span class="nav-text">decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9A%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1include"><span class="nav-number">1.20.</span> <span class="nav-text">预处理器：避免多次include</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">第三章 字符串、向量和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%AB%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8using"><span class="nav-number">2.1.</span> <span class="nav-text">别在头文件中使用using</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">2.2.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">处理字符的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4for"><span class="nav-number">2.4.</span> <span class="nav-text">范围for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">2.5.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E8%BF%90%E7%AE%97%E7%AC%A6-gt"><span class="nav-number">2.7.</span> <span class="nav-text">箭头运算符-&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.8.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.9.</span> <span class="nav-text">C风格字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8string%E4%B8%8Ec%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.10.</span> <span class="nav-text">混合使用string与c风格字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.11.</span> <span class="nav-text">使用数组初始化vector对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.12.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">第四章 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="nav-number">3.1.</span> <span class="nav-text">左值与右值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%AA%E5%AE%9A%E4%B9%89%E6%83%85%E5%86%B5"><span class="nav-number">3.2.</span> <span class="nav-text">求值顺序的未定义情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A9%E7%84%B6%E7%9A%84%E6%B5%B7%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">天然的海象表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9A%84%E8%BF%90%E7%AE%97%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.4.</span> <span class="nav-text">一些不清楚的运算顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.5.</span> <span class="nav-text">条件运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.6.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-static-cast"><span class="nav-number">3.7.</span> <span class="nav-text">类型转换: static_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-cast-lt-type-gt-old-num"><span class="nav-number">3.8.</span> <span class="nav-text">const_cast&lt;type&gt;(old_num)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%86static-cast%E4%B8%8Ereinterpret-cast"><span class="nav-number">3.9.</span> <span class="nav-text">区分static_cast与reinterpret_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TODO-dynamic-cast"><span class="nav-number">3.10.</span> <span class="nav-text">TODO: dynamic_cast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.</span> <span class="nav-text">第五章 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">4.1.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-while"><span class="nav-number">4.2.</span> <span class="nav-text">do-while</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9Atry-catch"><span class="nav-number">4.3.</span> <span class="nav-text">异常处理：try-catch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">第六章 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88const%E5%BD%A2%E5%8F%82%E6%98%AF%E5%8F%AF%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">为什么const形参是可行的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82"><span class="nav-number">5.2.</span> <span class="nav-text">数组作为形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8%E6%88%96%E6%8C%87%E9%92%88"><span class="nav-number">5.3.</span> <span class="nav-text">不要返回局部变量的引用或指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%8F%AF%E8%83%BD%E6%98%AF%E5%B7%A6%E5%80%BC"><span class="nav-number">5.4.</span> <span class="nav-text">返回结果可能是左值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.5.</span> <span class="nav-text">返回列表初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">5.6.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-cast%E4%B8%8E%E9%87%8D%E8%BD%BD%EF%BC%9A%E6%A0%BC%E5%A4%96%E6%9C%89%E7%94%A8"><span class="nav-number">5.7.</span> <span class="nav-text">const_cast与重载：格外有用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="nav-number">5.8.</span> <span class="nav-text">默认实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">5.9.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr%E5%87%BD%E6%95%B0"><span class="nav-number">5.10.</span> <span class="nav-text">constexpr函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86inline%E4%B8%8Econstexpr%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%9F"><span class="nav-number">5.11.</span> <span class="nav-text">为什么将inline与constexpr函数定义在头文件中？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8inline%EF%BC%8C%E8%80%8C%E8%A6%81static-inline%EF%BC%9F"><span class="nav-number">5.12.</span> <span class="nav-text">为什么最好不要单独使用inline，而要static inline？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="nav-number">5.13.</span> <span class="nav-text">assert与调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">5.14.</span> <span class="nav-text">选择哪个重载函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">5.15.</span> <span class="nav-text">函数指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">第七章 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">6.1.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">const成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">在类的外部定义函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Ethis"><span class="nav-number">6.4.</span> <span class="nav-text">返回this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E5%B9%85%E5%80%BC%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-number">6.6.</span> <span class="nav-text">拷贝、幅值与析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct"><span class="nav-number">6.7.</span> <span class="nav-text">struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">6.8.</span> <span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">6.9.</span> <span class="nav-text">友元类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.10.</span> <span class="nav-text">内联的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutable"><span class="nav-number">6.11.</span> <span class="nav-text">mutable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-number">6.12.</span> <span class="nav-text">类成员初始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.13.</span> <span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.14.</span> <span class="nav-text">转换构造函数与隐式的类类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8explicit%E9%98%BB%E6%AD%A2%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.15.</span> <span class="nav-text">使用explicit阻止隐式的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-number">6.16.</span> <span class="nav-text">聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.17.</span> <span class="nav-text">constexpr构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">6.18.</span> <span class="nav-text">类的静态成员</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E2%85%A1%E9%83%A8%E5%88%86%EF%BC%9AC-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number"></span> <span class="nav-text">第Ⅱ部分：C++标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9AIO%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">第八章：IO库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8DIO%E6%B5%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">三种IO流类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.</span> <span class="nav-text">文件输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">读写二进制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81sstream"><span class="nav-number">1.4.</span> <span class="nav-text">使用字符串流sstream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">第九章：顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">顺序容器类型与特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8%E9%83%BD%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.</span> <span class="nav-text">所有容器都支持的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">容器的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">顺序容器支持的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emplace%E4%B8%8Epush%E7%9A%84%E6%80%A7%E8%83%BD%E8%AE%A8%E8%AE%BA"><span class="nav-number">2.5.</span> <span class="nav-text">emplace与push的性能讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8resize"><span class="nav-number">2.6.</span> <span class="nav-text">使用resize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86vector%E7%9A%84%E6%89%A9%E5%BC%A0"><span class="nav-number">2.7.</span> <span class="nav-text">管理vector的扩张</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.</span> <span class="nav-text">额外的string操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">2.9.</span> <span class="nav-text">容器适配器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">第十章：泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9Afind%E4%B8%8Ecount"><span class="nav-number">3.1.</span> <span class="nav-text">一个好的例子：find与count</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">只读算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0"><span class="nav-number">3.3.</span> <span class="nav-text">写容器元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#back-inserter"><span class="nav-number">3.4.</span> <span class="nav-text">back_inserter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9Dcopy"><span class="nav-number">3.5.</span> <span class="nav-text">拷贝copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace%E4%B8%8Ecopy"><span class="nav-number">3.6.</span> <span class="nav-text">replace与copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort%E4%B8%8Eunique"><span class="nav-number">3.7.</span> <span class="nav-text">sort与unique</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E8%A1%8C%E4%B8%BA%EF%BC%9A%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.</span> <span class="nav-text">定制行为：向算法传递函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.9.</span> <span class="nav-text">lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-if"><span class="nav-number">3.10.</span> <span class="nav-text">find_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each%E7%AE%97%E6%B3%95"><span class="nav-number">3.11.</span> <span class="nav-text">for_each算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E7%9A%84%E5%80%BC%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7"><span class="nav-number">3.12.</span> <span class="nav-text">lambda的值捕获与引用捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E7%9A%84%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7"><span class="nav-number">3.13.</span> <span class="nav-text">lambda的隐式捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98lambda-%E4%BD%BF%E5%BE%97%E5%80%BC%E6%8D%95%E8%8E%B7%E5%8F%AF%E5%8F%98"><span class="nav-number">3.14.</span> <span class="nav-text">可变lambda:使得值捕获可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%EF%BC%9A%E6%97%A0%E6%B3%95%E6%8E%A8%E6%96%AD%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">3.15.</span> <span class="nav-text">lambda：无法推断返回值类型的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8bind%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.16.</span> <span class="nav-text">使用bind生成新的可调用对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">第十一章 关联容器</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lpdink"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">lpdink</p>
  <div class="site-description" itemprop="description">做更好的工作</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lpdink" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lpdink" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lpdink.github.io/2024/07/13/cxx_primer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="lpdink">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lpdink的博客">
      <meta itemprop="description" content="做更好的工作">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ Primer笔记 | lpdink的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-03 08:29:37" itemprop="dateModified" datetime="2023-06-03T08:29:37+00:00">2023-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本笔记是C++ Primer的阅读笔记，以知识点的形式呈现。<br>primer很长很长，所以本笔记也很长很长…</p>
<span id="more"></span>

<h2 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h2><h3 id="cerr与clog"><a href="#cerr与clog" class="headerlink" title="cerr与clog"></a>cerr与clog</h3><p>cerr不缓冲，用于显示错误信息，以及你不想被&gt; 转发到Log文件的信息。<br>clog可以作为输出log。  </p>
<h3 id="仅using必须的项目"><a href="#仅using必须的项目" class="headerlink" title="仅using必须的项目"></a>仅using必须的项目</h3><p>不使用using namespace xxx而仅仅using其中你需要的，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;</span><br></pre></td></tr></table></figure>

<h3 id="使用-i而不是i"><a href="#使用-i而不是i" class="headerlink" title="使用++i而不是i++"></a>使用++i而不是i++</h3><p>++i的效率比i++更高，且当我们使用自增时，往往希望自增先结算。</p>
<h1 id="第Ⅰ部分：C-基础"><a href="#第Ⅰ部分：C-基础" class="headerlink" title="第Ⅰ部分：C++基础"></a>第Ⅰ部分：C++基础</h1><h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><h3 id="内置类型与长度"><a href="#内置类型与长度" class="headerlink" title="内置类型与长度"></a>内置类型与长度</h3><p>在ubuntu20.04，g++ 9.4.0下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 整型</span><br><span class="line">bool 1</span><br><span class="line">char 1</span><br><span class="line">wchar_t 4 // 宽字符是内置类型哦</span><br><span class="line">char16_t 2</span><br><span class="line">char32_t 4</span><br><span class="line">short 2</span><br><span class="line">int 4</span><br><span class="line">long 8</span><br><span class="line">long long 8</span><br><span class="line">// 浮点</span><br><span class="line">float 4</span><br><span class="line">double 8</span><br><span class="line">long double 16</span><br></pre></td></tr></table></figure>

<p>单位是字节(8位)。<br>不要使用long，它的长度可能和int一样，有需求，直接long long。long long是C++11新定义的。<br>除bool整型可前置signed&#x2F;unsigned。<br>当char用作数字类型时，明确指示是signed char还是unsigned char，因为单纯char的范围由编译器实现决定。  </p>
<h3 id="警惕unsigned"><a href="#警惕unsigned" class="headerlink" title="警惕unsigned"></a>警惕unsigned</h3><ul>
<li>警惕unsigned的值经过计算（尝试）到达负值，此时会重回上界。</li>
<li>警惕unsigned的值与signed的值的比较。<br>在实际场景中，冒犯两个警惕的最常见场景是，stl容器的.size()，这个方法的返回值是unsigned的！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_except_last_err</span><span class="params">(<span class="type">const</span> vector&lt;T&gt; &amp;res_v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 警惕unsigned尝试变为负数.</span></span><br><span class="line">    <span class="comment">// 很隐晦的是stl容器的size()，这是一个unsigned！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本例是一个错误的示范：</span></span><br><span class="line">    <span class="comment">// vector.size()是unsigned的，如果vector长度为0，&lt;的右式会最大！进入循环后会Segmentation fault!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res_v.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; res_v[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法是：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_except_last_right</span><span class="params">(<span class="type">const</span> vector&lt;T&gt; &amp;res_v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; res_v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; res_v[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>真是令人怀念，当时的基础确实太差了…</p>
</blockquote>
<h3 id="不要依赖隐式转换和错误"><a href="#不要依赖隐式转换和错误" class="headerlink" title="不要依赖隐式转换和错误"></a>不要依赖隐式转换和错误</h3><p>不要依赖于错误，常见的是通过超出范围取得最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char char_max=-1;</span><br><span class="line">cout&lt;&lt;(int)char_max&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>在“不合常理”时，程序的行为是不确定的，可能错误，可能放过，可能产生随机值，这取决于你的编译器、编译flag，执行平台。<br>这是不可移植，或是难再现的，对debug来说很糟糕。</p>
<h3 id="“比’长一位"><a href="#“比’长一位" class="headerlink" title="“比’长一位"></a>“比’长一位</h3><p>‘就是单纯的char。”本质上则是常量字符构成的数组，且会在末尾固定添加’\0’。<br>在你对char*调用printf或cout时，他们会打印直到第一个’\0’。</p>
<h3 id="前缀与后缀"><a href="#前缀与后缀" class="headerlink" title="前缀与后缀"></a>前缀与后缀</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 前置</span><br><span class="line">u&quot;123456&quot; -&gt; char16_t</span><br><span class="line">U&quot;123456&quot; -&gt; char32_t</span><br><span class="line">L&quot;123456&quot; -&gt; wchar_t</span><br><span class="line">u8&quot;123456&quot; -&gt; char</span><br><span class="line">// 后缀</span><br><span class="line">12345u or 12345U -&gt; unsigned</span><br><span class="line">1.23f or 1.23F -&gt; float</span><br><span class="line">1234l or 1234L -&gt; long</span><br><span class="line">1.234l or 1.234L -&gt; long double</span><br><span class="line">1234ll or 1234LL -&gt;  long long</span><br></pre></td></tr></table></figure>

<h3 id="使用extern"><a href="#使用extern" class="headerlink" title="使用extern"></a>使用extern</h3><p>extern允许我们在一个cc文件中获取另一个cc文件的定义式(包括变量，函数和类定义)，而不必通过.h，只要最后将两个cc文件联合起来编译就可以了。  </p>
<blockquote>
<p>我总感觉这不太妙，这在破坏封装性。  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// file1.cc,对非const的情况，在定义式中可以略去extern.这是默认选项。</span><br><span class="line">// 这也解释了我们为什么一定要命名空间，默认extern太容易造成命名空间污染了！</span><br><span class="line">extern int test=1;</span><br><span class="line">...</span><br><span class="line">// file2.cc</span><br><span class="line">// 这里是声明式,编译器会放过这里,让链接器去找定义式,找不到时,链接器报错.</span><br><span class="line">extern int test;</span><br><span class="line">...</span><br><span class="line">cout&lt;&lt;test&lt;&lt;end;</span><br></pre></td></tr></table></figure>

<p>如上所示，这样就能直接在file2中获得file1.cc定义的变量&#x2F;常量了。<br>如果你没有同时编译他们，只编译file2.cc，会报undefined reference的错误。  </p>
<blockquote>
<p>变量只能被定义一次，但可以被多次声明。</p>
</blockquote>
<p>默认extern非常容易造成命名空间污染：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你在两个cc文件中定义了相同签名的函数，就会出现multiple definition的错误！</span></span><br><span class="line"><span class="comment">// file1.cc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"><span class="comment">// file2.cc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误信息：multiple definition of `test(int, int)&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个错误也令人怀念…celt_lpc.</p>
</blockquote>
<p>在编译库提供给外部语言调用时，如果两个库中不加namespace地提供了同签名函数。外部语言编译器或解释器的行为是难以控制的，是不通过，还是随机调用其中一个？因此，绝对不要这么做，应该尽力通过namespace避免这一情况。</p>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>extern “C”是C++&#x2F;C混编的方案，在C++中使用extern “C”修饰函数，<strong>并不是</strong>在告诉C++编译器将工作交给C编译器去做，而是使用C++编译器，按照C风格去编译这里。<br>什么是C风格？具体来说，就是不按照函数重载规则重命名这里的函数符号。<br>C++支持了函数重载，这并不是通过真的保存两个同名符号，而是通过某种规则，根据你的函数签名重命名了同名符号，保证不冲突。这意味着你定义的函数名会被编译器修改。<br>C不支持函数重载，所以你写的函数名，就会被编译器直接拿去用，写在库中的，也是你写的函数名，它与头文件写的接口一致。<br>外部语言并不一定能理解C++的重名规则(例如JNI)，此时，用extern C能确保外部语言按照你给的.h文件，真的能找到函数定义。<br>对于你要暴露给外部语言的接口(.h)文件，添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">// ...你的声明式...</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>保证你要暴露的函数声明在extern “C”包裹中即可，至于namespace声明，包含与否都无关痛痒。<br>但与此同时，如果使用C++重载去理解声明式(头文件)是外部语言的默认，(例如C++)，但你却贴心地在暴露接口时使用了extern “C”，那么在引用接口时，记得也要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">    #include &quot;your_interface.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>extern “C”仍然是C++编译器在编译，所以你可以在其中尽情地使用C++特性！</strong></p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>在可见性上，static与extern相对。<br>被static修饰的符号，只能在定义的作用域内可见，对外部不可见。<br>static可能有以下的几种状态：</p>
<ul>
<li>静态局部变量：<br>在全局数据区分配内存，要求在声明处c初始化，只被初始化一次，值会保存到下一次函数调用。(因为内存空间在全局数据区，而不是栈上，栈上数据会被回收。)</li>
<li>静态全局变量：<br>对其他文件完全不可见，避免命名冲突。</li>
<li>静态函数：<br>与静态全局变量一致，对其他文件不可见，避免命名冲突。</li>
<li>静态成员变量：<br>其实就是类变量。</li>
<li>静态成员函数：<br>其实就是类函数。</li>
</ul>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>引用是对象的别名，因此必须有对象（即引用必须被初始化）。<br>与python的引用不同，这是真正的别名。对赋值语句也作用！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int val=1024;</span><br><span class="line">int val2=2048;</span><br><span class="line">int &amp;ref_val=val;</span><br><span class="line">ref_val=val2;</span><br><span class="line">std::cout&lt;&lt;val&lt;&lt;&quot; &quot;&lt;&lt;val2&lt;&lt;&quot; &quot;&lt;&lt;ref_val&lt;&lt;&quot; &quot;&lt;&lt;std::endl;</span><br><span class="line">// result:</span><br><span class="line">// 2048 2048 2048</span><br></pre></td></tr></table></figure>

<p>不能创建引用的引用(这句话容易令人误解，这不是指，一个引用绑定到某个对象后，不能通过该引用创建到该对象的新引用，而是指不能创建到某个引用本身的引用)。<br>你大可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int &amp;ref_val=val;</span><br><span class="line">int &amp;ref_val2=ref_val;</span><br></pre></td></tr></table></figure>

<h3 id="使用nullptr，不再使用NULL"><a href="#使用nullptr，不再使用NULL" class="headerlink" title="使用nullptr，不再使用NULL"></a>使用nullptr，不再使用NULL</h3><p>这是新标准的现代C++的推荐。</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h3><p>指向任何存放任何对象的地址。<br>void*指针的确存放一个地址，但是我们不知道该地址里的对象是什么。<br>它看上去作用有限，无法被直接解引用，但是可以作为一个多类型分发的办法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int tmp=114514;</span><br><span class="line">void *ptr=&amp;tmp;</span><br><span class="line">int *int_ptr;</span><br><span class="line">int_ptr=(int* )ptr; // 只要你知道void*指向的是什么类型...就能通过强转拿到值</span><br></pre></td></tr></table></figure>

<h3 id="属于var，而不是type"><a href="#属于var，而不是type" class="headerlink" title="*属于var，而不是type"></a>*属于var，而不是type</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// p1是int*，p2是int。</span><br><span class="line">int *p1,p2;</span><br><span class="line">// 所以不要这样写，会导致误解。*修饰的是变量。</span><br><span class="line">int* p1, p2;</span><br></pre></td></tr></table></figure>

<h3 id="高阶指针"><a href="#高阶指针" class="headerlink" title="高阶指针"></a>高阶指针</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int val = 1024;</span><br><span class="line">int *p = &amp;val; //一般的一阶指针，左值是指针，右值是地址。</span><br><span class="line">int **pp=&amp;p; //二阶指针</span><br></pre></td></tr></table></figure>

<h3 id="创建指针的引用"><a href="#创建指针的引用" class="headerlink" title="创建指针的引用"></a>创建指针的引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int val=42;</span><br><span class="line">int *p=&amp;val;</span><br><span class="line">int *&amp;ref_p=p; //引用的类型是int *， 所以&amp;在*后面。</span><br></pre></td></tr></table></figure>

<p>对于更高阶的（为难人的情况），推荐从右向左读，是&amp;就是引用，是*就是指针。  </p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>可见性<br>默认情况下，const变量只在文件内部有效。要使得它能被外部cxx取得，需要用extern声明。</li>
<li><strong>const与引用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 你可以这样做，但这没啥用。</span><br><span class="line">const int ci=42;</span><br><span class="line">const int &amp;same_ci=ci;</span><br><span class="line">// 更常见的是，创建一个非const对象的const引用</span><br><span class="line">int ci=42;</span><br><span class="line">const int &amp;you_cant_change_ci=ci;</span><br></pre></td></tr></table></figure>

<p>创建一个非const对象的const引用是非常有用的，通常在定义函数时，形参被定义为一个const引用，但是传递进来的实参本身并不是const的。这使得我们能传递引用，但是保证函数不修改我们的对象。</p>
<ul>
<li><strong>const与指针</strong><br><strong>指向常量的指针</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正指向常量的指针，很少这样做.</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> val=<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* val_ptr=&amp;val;</span><br><span class="line"><span class="comment">// 实际上指向了一个非const的对象的，形式上指向const对象的指针（我要笑死了）</span></span><br><span class="line"><span class="comment">// 然而这很有用，阻止获得val_ptr的人修改val。</span></span><br><span class="line"><span class="type">int</span> val=<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* val_ptr=&amp;val;</span><br></pre></td></tr></table></figure>

<p>与引用一样，你传递一个指向const对象的指针（它实际上指向了一个非const对象），可以阻止获得指针的函数修改这个对象。<br>这一做法也常用在函数的形参定义时。  </p>
<p><strong>常指针&#x2F;顶层const</strong><br>常指针指，指针指向的地址本身不能变化，但是地址内的值可以变化。感觉用的比较少。<br>底层const则指，指针指向的对象是常量，指针本身指向的地址则可以变化。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr=&amp;val; <span class="comment">//ptr将一直指向&amp;val地址，但是不会管里面的值是否变化。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> another_ptr=&amp;val; <span class="comment">//another_ptr将一直指向&amp;val地址，并且保证不能通过another_ptr修改&amp;val存储的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="constexpr常量表达式"><a href="#constexpr常量表达式" class="headerlink" title="constexpr常量表达式"></a>constexpr常量表达式</h3><p>C++11特性。<br>这是一种在<strong>编译时</strong>由编译器计算结果的表达式，而不是在运行时计算。<br>得到计算结果后，该对象与const在运行时的行为一致。<br>你可以将一切你认为应该是constexpr的表达式声明成constexpr的，如果不是，编译器会告诉你的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res_vec;</span><br><span class="line"><span class="comment">// 如果你尝试这样做，编译器会报错。</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> length = res_vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// error: call to non-‘constexpr’ function ‘std::vector</span></span><br></pre></td></tr></table></figure>

<p>你不能这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int val=42;</span><br><span class="line">constexpr int double_val=val+val;</span><br></pre></td></tr></table></figure>

<p>但是却可以这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int val=42;</span><br><span class="line">const int double_val=val+val;</span><br></pre></td></tr></table></figure>

<p>因为constexpr保证会在编译时得到结果并替换，但const没有许下这样的承诺。<br>如果追求执行时性能，使用constexpr十分美妙。<br><strong>constexpr与指针：</strong><br>不要用constexpr修饰指针！<br>constexpr修饰指针，不会使得指向的对象成为常量，永远会使你创建的指针是一个常指针！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// 这是指向常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">// 这是常指针！</span></span><br></pre></td></tr></table></figure>

<p>你可以混用constexpr与const创建一个指向常量的常指针，但是，你可以用两个const完成这一工作，所以别把constexpr与指针放在一起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p=<span class="literal">nullptr</span></span><br><span class="line"><span class="comment">// is eq to </span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="type">int</span> val=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p=&amp;val;</span><br><span class="line"><span class="comment">// is eq to </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p=&amp;val;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但话说回来，constexpr const int *ptr这种写法真的好漂亮哦，比const int* const ptr好看多了…</p>
</blockquote>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>除了typedef，11标准支持了一种新写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef double MyDouble;</span><br><span class="line">using MyInt=int; // 11标准</span><br></pre></td></tr></table></figure>

<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto也是c++11新支持的。  </p>
<ul>
<li>与const</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> val=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a=val; <span class="comment">//a 不是const的，顶层const被忽略了。</span></span><br><span class="line"><span class="keyword">auto</span> p=&amp;val <span class="comment">//p是一个指向const的指针，底层const被保留了。</span></span><br><span class="line"><span class="comment">// 如果希望保留顶层const:</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> another_a=val;</span><br></pre></td></tr></table></figure>

<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>C++11新支持的。<br>可以从表达式或函数的结果取得类型（并不实际执行表达式或函数）。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">decltype(i) x=84;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>见了能认识就行了…你不会真想用这个吧，额</p>
</blockquote>
<h3 id="预处理器：避免多次include"><a href="#预处理器：避免多次include" class="headerlink" title="预处理器：避免多次include"></a>预处理器：避免多次include</h3><p>#系列的命令由预处理器执行，包括include。<br>它的工作逻辑非常简单，发现#include，找到include的文件，将内容复制到当前文件。<br>这带来一个问题，在层级引用中，有可能会出现多重include:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.h</span></span><br><span class="line">define something</span><br><span class="line"><span class="comment">// file2.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line">define something</span><br><span class="line"><span class="comment">// file3.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file2.h&quot;</span> <span class="comment">//由于file2也引入了file1，这里会导致file1被多次引入</span></span></span><br><span class="line">define something</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决这个问题的办法就是通过定式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef YOUR_H_FILE_NAME_H</span><br><span class="line">#define YOUR_H_FILE_NAME_H</span><br><span class="line">// 正文</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><strong>这是一个routine，你永远应该这样做，没有例外。</strong></p>
<h2 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h2><h3 id="别在头文件中使用using"><a href="#别在头文件中使用using" class="headerlink" title="别在头文件中使用using"></a>别在头文件中使用using</h3><p>因为头文件会被别的文件include，进行替换时引入命名符号绝对不好！</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">using std::string;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2=s1; <span class="comment">// or string s2(s1);</span></span><br><span class="line">string s3=<span class="string">&quot;aljd&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>)</span></span>;<span class="comment">//&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;执行的是拷贝初始化，()执行的是直接初始化。在C++20中可以用{}初始化，先别那么做吧。  </p>
<ul>
<li>使用getline从流中读取一行：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">getline(file_stream, s);// 遇到\n时停止，\n也会被读入。</span><br></pre></td></tr></table></figure>

<ul>
<li>empty()</li>
<li>size()<br>size返回的既不是int，也不是unsigned int，而是string::size_type。（不过它是unsigned的）<br><strong>建议</strong>：如果用了size()，最好别用int，避免int与unsigned混用的问题。  </li>
<li>sub</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s=&quot;12345&quot;;</span><br><span class="line">s.sub(begin_index, nums);//注意第二个参数是个数。</span><br></pre></td></tr></table></figure>

<h3 id="处理字符的函数"><a href="#处理字符的函数" class="headerlink" title="处理字符的函数"></a>处理字符的函数</h3><p>定义在头文件cctype中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isalnum</span>(c) <span class="comment">//c为字母或数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c) <span class="comment">//c为字母</span></span><br><span class="line"><span class="built_in">iscntrl</span>(c) <span class="comment">//c为控制字符</span></span><br><span class="line"><span class="built_in">isdigit</span>(c) <span class="comment">//c为数字</span></span><br><span class="line"><span class="built_in">isgraph</span>(c) <span class="comment">//c不是空格，但可打印</span></span><br><span class="line"><span class="built_in">islower</span>(c) <span class="comment">//c是小写字母</span></span><br><span class="line"><span class="built_in">isprint</span>(c) <span class="comment">//c可打印</span></span><br><span class="line"><span class="built_in">ispunct</span>(c) <span class="comment">//c是标点符号(不是控制字符，数字，字母，可打印空白中的一种)</span></span><br><span class="line"><span class="built_in">isspace</span>(c) <span class="comment">//c是空白(包括空格，横纵向制表符，回车，换行，进纸符)</span></span><br><span class="line"><span class="built_in">isupper</span>(c) <span class="comment">//c是大写字母</span></span><br><span class="line"><span class="built_in">isxdigit</span>(c) <span class="comment">//c是十六进制数字</span></span><br><span class="line"><span class="built_in">tolower</span>(c) <span class="comment">//c转小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c) <span class="comment">//c转大写</span></span><br></pre></td></tr></table></figure>

<p><strong>建议</strong>：C++兼容了C的标准库头文件，对c的name.h，C++将他们命名为cname。所以，这里cctype与ctype.h头文件的内容是一致的。编写C++时，推荐用C++风格的头文件。</p>
<h3 id="范围for"><a href="#范围for" class="headerlink" title="范围for"></a>范围for</h3><p>范围for实际上在执行一个拷贝，所以，当你想要修改值时，需要添加引用&amp;.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s=&quot;qwerty&quot;;</span><br><span class="line"></span><br><span class="line">for(auto&amp; c:s)&#123;</span><br><span class="line">    ... // c是引用，故可以修改s。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也能看出与python的不同。C++的string是char数组，而不是不可变序列。你可以修改其中的任何一个字符，这个过程没有在创建新字符串。</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vecotr&lt;T&gt; v1;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line">vector&lt;T&gt; v2=v1;<span class="comment">//对元素拷贝的</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n, val)</span></span>;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n)</span></span>;<span class="comment">//会采用T的默认值</span></span><br><span class="line">vector&lt;T&gt; v4&#123;a,b,c...&#125;;<span class="comment">//C++11已经有这种写法了</span></span><br><span class="line">vector&lt;T&gt; v4=&#123;a,b,c&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>警告：C++标准要求vector优先对动态增长高效，在初始阶段指定vector的大小甚至会降低效率！(除非所有元素的值相同)。这与python不同。</strong></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>除了下标运算符，还可以利用迭代器访问容器元素。<br>所有的标准库容器都可以使用迭代器。<br>string不算容器，但也可以使用迭代器。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// end()返回的迭代器并不实际指向某个元素，只作为\0</span></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>()!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); <span class="comment">// 使用auto获得迭代器。</span></span><br><span class="line">    <span class="comment">// 迭代器的行为与指针非常像：</span></span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器的行为与指针类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*iter 解引用</span><br><span class="line">iterm-&gt;mem 解引用并访问mem成员，等价于 (*item).mem</span><br><span class="line">++iter 访问下一个</span><br><span class="line">--iter 访问上一个</span><br><span class="line">iter1 == iter2 判断两个迭代器是否指向相同元素</span><br></pre></td></tr></table></figure>

<p><strong>建议</strong>并不是所有的标准库容器都定义了迭代器的&lt;或！因此，总是使用!&#x3D;来判断迭代器是否走到了末尾。  </p>
<ul>
<li>迭代器的真实类型<br>我们总是用auto访问，但迭代器的真实类型是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">vector&lt;int&gt;::const_iterator it2;// const 迭代器，只能读不能写</span><br></pre></td></tr></table></figure>

<ul>
<li>cbegin与cend<br>使用begin与end时，返回元素是否const由元素本身是否const决定。<br>如果一定要获取const，使用cbegin与cend方法。</li>
<li>迭代器是支持一次+num或-num的，因此可以方便地用于复杂情况（如二分查找）。</li>
</ul>
<h3 id="箭头运算符-gt"><a href="#箭头运算符-gt" class="headerlink" title="箭头运算符-&gt;"></a>箭头运算符-&gt;</h3><p>是解引用(*)与访问元素(.)运算符的组合。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterm-&gt;mem 解引用并访问mem成员，等价于 (*item).mem</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的长度固定，要求在定义时给出，[]内必须至少是一个常量表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num[a_constexpr];</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化</li>
</ul>
<p>在栈内，默认初始化会让数组拥有随机值, 如果要置零，用&#x3D;{0}。<br>在堆上，被初始化为0。  </p>
<ul>
<li>字符数组</li>
</ul>
<p>字符数组有一个\0的结尾约定，故存在，你需要\0，你不需要\0两种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[]=&#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;; <span class="comment">// 不会添加\0</span></span><br><span class="line"><span class="type">char</span> a1[]=&#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 你自己添加了\0</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>; <span class="comment">// 编译器为你自动添加\0</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">3</span>]=<span class="string">&quot;C++&quot;</span>; <span class="comment">// 报错，没有空间添加\0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不允许拷贝和赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[]=a;<span class="comment">// 错误，没有拷贝构造函数</span></span><br><span class="line">a2 = a; <span class="comment">//错误，不允许赋值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组支持范围for访问！</li>
</ul>
<p>因为数组的维度是固定的，算作数组属性的一部分，编译器是知道数组大小的。<br>因此这是可以(且推荐)的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; element:array)&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用begin与end访问数组的首(尾+1)元素</li>
</ul>
<p>C++11特性。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>&#125;;</span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(ia); <span class="comment">// 指向1</span></span><br><span class="line"><span class="type">int</span> *last = <span class="built_in">end</span>(ia); <span class="comment">// 指向45的下一位置。不能对last解引用！</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下标和指针</li>
</ul>
<p>这里同样演示一种等价：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = array;<span class="comment">// 等价于int *p = &amp;array[0]</span></span><br></pre></td></tr></table></figure>

<p>注意，数组的[]是取值运算！返回的是数组中的值而不是地址。<br>如果要获得数组某个元素的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;array[i];</span><br><span class="line">或</span><br><span class="line">array+i;</span><br></pre></td></tr></table></figure>

<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>c风格字符串即常用的字符串字面值。<br>定义在头文件&lt;cstring&gt;(c++)或&lt;string.h&gt;(c)中的方法用于支持他们。<br>C标准库的方法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(p)</span><br><span class="line"><span class="built_in">strcmp</span>(p1, p2) <span class="comment">//p1==p2,ret=0, p1&lt;p2 ret=-num, p1&gt;p2,ret=+num</span></span><br><span class="line"><span class="built_in">strcat</span>(p1, p2) <span class="comment">//p1+p2</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1, p2) <span class="comment">//p1=p2</span></span><br></pre></td></tr></table></figure>

<p>strlen方法实际上在尝试找到\0，如果一个const char*没有\0，会产生未定义的情况…<br>strcat要求一个新的空间，这个空间足够大，能放下p1+p2。然而这个空间是用户申请的，如果大小计算错误，也将引发严重的内存错误。  </p>
<p><strong>建议</strong>：因此，除了极少的用于字符串字面量的情况，不使用c风格字符串，能string尽量string。</p>
<h3 id="混合使用string与c风格字符串"><a href="#混合使用string与c风格字符串" class="headerlink" title="混合使用string与c风格字符串"></a>混合使用string与c风格字符串</h3><blockquote>
<p>这就是所谓的，C++沉重的历史包袱(的很少一部分)</p>
</blockquote>
<p>可以使用string.c_str()获取一个const char*，这是将string降级为c风格字符串的方法。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;12345&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *c_s=s; <span class="comment">// 错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *c_s=s.<span class="built_in">c_str</span>(); <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">// 对s的修改会反映到c_s上。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h3><p>使用字面值初始化vector是显然的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>但是下面的做法不行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = nums;</span><br></pre></td></tr></table></figure>

<p>应该这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(begin(nums), end(nums))</span></span>;</span><br><span class="line"><span class="comment">// 这里用cbegin和cend也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(nums, nums+<span class="number">5</span>)</span></span>; <span class="comment">// 注意是+5，即使+5访问不到.</span></span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">// 这会将2*3*4都初始化为0；</span></span><br></pre></td></tr></table></figure>

<p>多维数组是支持范围for的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row:a)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col:a)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 使用范围for遍历多维数组，只有最内层循环可以不使用引用。</p>
<blockquote>
<p>如果你尝试在外层循环不使用引用，编译器会报错，auto会将通过外层循环得到的量理解为指针而不是数组。你尝试遍历一个int*指针，当然会报错。  </p>
</blockquote>
<h2 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h2><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p>右值(rvalue)读are-value,左值(lvalue)读ell-value。<br>在C中，概念很简单，左值能出现在赋值语句左侧，右值则不能。<br>在C++中，比较复杂。当一个对象被用作右值时，用的是对象的值&#x2F;内容，当对象被用作左值的时候，用的是对象的身份（在内存中的位置）  </p>
<h3 id="求值顺序的未定义情况"><a href="#求值顺序的未定义情况" class="headerlink" title="求值顺序的未定义情况"></a>求值顺序的未定义情况</h3><p>一个常见的情景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;++i&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>&lt;&lt;运算符与++运算符的顺序是未定义的。  </p>
<blockquote>
<p>令人吃惊的是，f(x)*g(x)的顺序也是未定义的，f(x)和g(x)一定会在*之前调用，但他们的调用顺序是不确定的。  </p>
</blockquote>
<h3 id="天然的海象表达式"><a href="#天然的海象表达式" class="headerlink" title="天然的海象表达式"></a>天然的海象表达式</h3><p>C++天然支持海象表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>((i=<span class="built_in">get_value</span>())==<span class="number">42</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;i is eq to 42&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意赋值语句的优先级很低，因此必须加括号。</p>
<h3 id="一些不清楚的运算顺序"><a href="#一些不清楚的运算顺序" class="headerlink" title="一些不清楚的运算顺序"></a>一些不清楚的运算顺序</h3><p>自增运算符与其他运算符混合，运算顺序往往都不清楚：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;*iter++&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 这里会先对iter解引用，再++。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然primer建议读者写这样的语句，但是笔者不建议你这么写。  </p>
</blockquote>
<blockquote>
<p>在笔者的观点里，除了教学和装x，你永远不应该将自增运算符与双目运算符混用。  </p>
</blockquote>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>C++是支持条件运算符的，享受它吧！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> failed = (score&lt;<span class="number">60</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你不应该嵌套条件运算符，除非你在写算法题。</p>
</blockquote>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ 按位求反</span><br><span class="line">&lt;&lt;  &gt;&gt;左移右移</span><br><span class="line">&amp; 位与</span><br><span class="line">^ 位异或</span><br><span class="line">| 位或</span><br></pre></td></tr></table></figure>

<h3 id="类型转换-static-cast"><a href="#类型转换-static-cast" class="headerlink" title="类型转换: static_cast"></a>类型转换: static_cast</h3><p>C风格的强制类型转换(即前置(type))非常不推荐，应该使用static_cast或reinterpret_cast取代它。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> num=<span class="number">4.2</span>;</span><br><span class="line"><span class="type">void</span> *p=&amp;num;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<h3 id="const-cast-lt-type-gt-old-num"><a href="#const-cast-lt-type-gt-old-num" class="headerlink" title="const_cast&lt;type&gt;(old_num)"></a>const_cast&lt;type&gt;(old_num)</h3><p>const_cast可以去掉底层const。由于const指针可以指向非const对象，因此在<strong>必要条件</strong>下，去掉const指针的const还是可以的（如果它实际上指向了一个非const对象）。<br>但是，如果它指向了一个const对象，使用const_cast后的写行为是非常危险的，是未定义而取决于编译器的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num=<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr=&amp;num;</span><br><span class="line"><span class="type">int</span> *new_ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;num);</span><br><span class="line">*new_ptr=<span class="number">88</span>;</span><br><span class="line">cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*ptr&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*new_ptr&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 执行结果是</span></span><br><span class="line"><span class="comment">// 42 88 88</span></span><br></pre></td></tr></table></figure>

<p>看上去，g++守护了我们最好的const int，但是对指向该const int的指针则不然。我们不禁要问，这里发生了新的内存分配吗？我们在哪里申请了两个int的空间？  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr=num;</span><br><span class="line"><span class="type">int</span> *new_ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);</span><br><span class="line">*new_ptr=<span class="number">88</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n:num)&#123;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是88 2 3</span></span><br></pre></td></tr></table></figure>

<p>所以，上面的情况只是编译器变的戏法，它先将const int这样的常量做了全局的替换，就像#define一样。<br><strong>num</strong>的值，它的地址存储的值，已经改变了。  </p>
<blockquote>
<p>g++什么也没守护…我哭死…</p>
</blockquote>
<h3 id="区分static-cast与reinterpret-cast"><a href="#区分static-cast与reinterpret-cast" class="headerlink" title="区分static_cast与reinterpret_cast"></a>区分static_cast与reinterpret_cast</h3><p>static_cast用于“存在某种转换协议”时，常见的情况有：</p>
<ol>
<li>用于类层次结构中基类和派生类之间指针或引用的转换<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换为void类型</li>
</ol>
<p>reinterpret_cast如其名，用于类型的重新解释，是一种低层次的转换，它并没有直接做什么，只是让编译器重新去理解一个变量。<br>我们的数值实际上以字节为最小单位存放在申请的空间中，该空间被用“变量类型”(作为协议)来解释。<br>reinterpret就是用新的变量类型(新协议)来解释相同的一块内存空间。<br>这里提供一个较好的，应用了三种转换的实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;0123456789-abcdefgh&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s_c=s.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="type">char</span>* writable_sc = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(s_c);</span><br><span class="line"><span class="comment">// 重解释为unsigned char</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *uc_writable_sc=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(writable_sc);</span><br><span class="line"><span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// \0==0</span></span><br><span class="line">uc_writable_sc[<span class="number">1</span>]=<span class="number">242</span>; <span class="comment">// 修改使超出signed char范围</span></span><br><span class="line">uc_writable_sc[<span class="number">2</span>]=<span class="number">-42</span>;</span><br><span class="line"><span class="keyword">while</span>((uc_writable_sc[idx])!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    cout&lt;&lt;writable_sc[idx]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(writable_sc[idx])&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;uc_writable_sc[idx]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(uc_writable_sc[idx++])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;uc_writable_sc&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;writable_sc&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s_c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0 48 0 48</span><br><span class="line">� -14 � 242</span><br><span class="line">� -42 � 214</span><br><span class="line">3 51 3 51</span><br><span class="line">4 52 4 52</span><br><span class="line">5 53 5 53</span><br><span class="line">6 54 6 54</span><br><span class="line">7 55 7 55</span><br><span class="line">8 56 8 56</span><br><span class="line">9 57 9 57</span><br><span class="line">- 45 - 45</span><br><span class="line">a 97 a 97</span><br><span class="line">b 98 b 98</span><br><span class="line">c 99 c 99</span><br><span class="line">d 100 d 100</span><br><span class="line">e 101 e 101</span><br><span class="line">f 102 f 102</span><br><span class="line">g 103 g 103</span><br><span class="line">h 104 h 104</span><br><span class="line">// string被改变了！它本来是一个const char*的。</span><br><span class="line">0��3456789-abcdefgh 0��3456789-abcdefgh 0��3456789-abcdefgh 0��3456789-abcdefgh</span><br></pre></td></tr></table></figure>

<p>可以看到，在0-127范围内，char与unsigned char的行为是完全一致的，只有在我们有意的超出两个类型的范围的修改上表现出差异。<br>static, reinterpret, const三种cast都发生在编译时期。  </p>
<h3 id="TODO-dynamic-cast"><a href="#TODO-dynamic-cast" class="headerlink" title="TODO: dynamic_cast"></a>TODO: dynamic_cast</h3><p>运行时执行的，运行时进行类型检查，需要自定义类型且具备虚函数，不能用于内置类型。<br>在后面推进到虚函数时来补充。</p>
<h2 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        i+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 如果注释掉本行，会进入case 2;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        i+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        i=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 如果没有一个case触发，执行这里</span></span><br><span class="line">        i=<span class="number">-99</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ;;;</span><br><span class="line">&#125;<span class="keyword">while</span>(bool_exp)</span><br></pre></td></tr></table></figure>

<h3 id="异常处理：try-catch"><a href="#异常处理：try-catch" class="headerlink" title="异常处理：try-catch"></a>异常处理：try-catch</h3><p>由于真实系统的边界情况极多，异常处理逻辑复杂。如果与业务逻辑交织在一起，将令维护者难以快速判断哪里是(处理99%情况的)核心代码。<br>因此，在程序架构上，应该将异常捕获&#x2F;处理的代码与业务逻辑分离开来，在底层遇到边界情况时抛出异常，在最上层捕获异常，并进行处理。  </p>
<ul>
<li>使用throw抛出异常</li>
</ul>
<blockquote>
<p>标准库异常定义在stdexcept头文件中</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;a runtime error msg&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用try-catch捕获异常</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (runtime_error err)&#123;</span><br><span class="line">    cout&lt;&lt;err.<span class="built_in">what</span>();<span class="comment">//what 被标准库的所有异常提供</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stdexcept中定义的异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exception // 最常见的异常，不允许提供任何信息，只能默认初始化。</span><br><span class="line">runtime_error 描述 // 被以下四个继承，本身也可以作为一种异常使用</span><br><span class="line">range_error 边界错误</span><br><span class="line">overflow_error 上溢</span><br><span class="line">underflow_error 下溢</span><br><span class="line">system_error 系统错误</span><br><span class="line"></span><br><span class="line">logic_error 描述 // 被以下四个继承，本身也可以作为一种异常使用</span><br><span class="line">domain_error 域错误</span><br><span class="line">invalid_argument 非法参数</span><br><span class="line">length_error 通常是创建对象是给出的尺寸太大</span><br><span class="line">out_of_range 访问超界</span><br><span class="line">future_error 未知错误</span><br></pre></td></tr></table></figure>

<h2 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h2><h3 id="为什么const形参是可行的？"><a href="#为什么const形参是可行的？" class="headerlink" title="为什么const形参是可行的？"></a>为什么const形参是可行的？</h3><p>使用实参初始化形参时，会忽略顶层const。  </p>
<h3 id="数组作为形参"><a href="#数组作为形参" class="headerlink" title="数组作为形参"></a>数组作为形参</h3><p>以下三种写法是等价的，且不会构成函数重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>第三种写法暗示着作者期待一个长为10的数组传入，但C++不会为你做这样的检查。必须由作者保证不进行越界访问。  </p>
<blockquote>
<p>数组传参的本质是传一个int<em>，因此用int</em>替代数组传参，这更加清晰。  </p>
</blockquote>
<p>传递一个指针，再传递（合法的）长度，不如传递两个指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg, <span class="type">const</span> <span class="type">int</span> *end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg!=end)</span><br><span class="line">        cout&lt;&lt;*beg++&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是标准库容器的常见初始化方法，这很好。  </p>
<h3 id="不要返回局部变量的引用或指针"><a href="#不要返回局部变量的引用或指针" class="headerlink" title="不要返回局部变量的引用或指针"></a>不要返回局部变量的引用或指针</h3><p>在局部栈上申请的对象，如果返回对象，其实是在返回对象的拷贝，因为栈上空间会在离开栈时被回收。<br>但是编译器的实际实现却不这么做，我们来看这样的示例：<br>为了方便演示，定义一个类Node，它在被创建时输出new，被销毁时输出delete。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;new&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们在局部变量中在栈上创建一个node，并将它返回，外层的node和里层的node是同一个吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">ret_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node node = <span class="built_in">Node</span>();</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;node inside addr:&quot;</span>&lt;&lt;&amp;node&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node node = <span class="built_in">ret_node</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;outside node addr:&quot;</span> &lt;&lt; &amp;node &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new</span><br><span class="line">node inside addr:0x7fff31dbe477</span><br><span class="line">outside node addr:0x7fff31dbe477</span><br><span class="line">delete</span><br></pre></td></tr></table></figure>

<p>是同一个！(但是先等等，继续往下看)<br>这意味着我们可以返回栈上对象的地址或指针吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">ret_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node node = <span class="built_in">Node</span>();</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;node inside addr:&quot;</span>&lt;&lt;&amp;node&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> &amp;node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对被回收的对象解引用本身就是危险的！</span></span><br><span class="line">    Node node = *(<span class="built_in">ret_node</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;outside node addr:&quot;</span> &lt;&lt; &amp;node &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// node再次被析构也是危险的！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new</span><br><span class="line">node inside addr:0x7fff548910a7</span><br><span class="line">delete</span><br><span class="line">outside node addr:0x7fff548910d7</span><br><span class="line">delete</span><br><span class="line">// node只被构造了一次，但析构了两次！</span><br><span class="line">// 如果node具备堆上申请空间的数据成员，执行两次析构函数意味着segmentation fault！</span><br><span class="line">// 然而，对被回收的内存解引用本身就是危险的！</span><br></pre></td></tr></table></figure>

<p>答案是绝不。并且在你尝试编译返回栈上对象地址或指针的程序时，g++会警告你：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: address of local variable ‘node’ returned [-Wreturn-local-addr]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这不是primer的内容，但是笔者在这里给出解释。</p>
</blockquote>
<blockquote>
<p>g++在做某种“偷懒”的行为(或者说是右值引用？)。事实是，你返回了一个在栈上申请的对象，按照标准，它应该在离开作用域后被回收，并重新申请空间，拷贝这个对象，以供外部访问。</p>
</blockquote>
<blockquote>
<p>但是既然它（因为你的返回语句）被外部取得了，g++貌似选择了直接将它的内存空间的管理权限移交给外部(我们的main函数)，这就节省了重新申请内存，并对Node调用拷贝构造函数的开销。</p>
</blockquote>
<blockquote>
<p>这是编译器的优化选择，但你不能依赖于它，因为这不是标准的一部分。标准从来没有承诺，你return的局部栈上变量的地址不会变化。</p>
</blockquote>
<blockquote>
<p>当我们尝试(恶意地)去利用这一特性时，却没有得到预期的结果。在我们返回引用时，局部对象被回收了。我们的小聪明失败了。这很好。<br>但我们还是要多问一句，为什么在返回引用的版本，析构函数被调用了两次呢？<br>我猜测和(右值引用)的判断有关。之前的优化逻辑只在用户尝试返回一个较大内存占用的对象时作用，但如果用户返回了一个地址，那拷贝与重新申请空间的开销显然不太大。此时，局部的变量离开了作用域，当然会被回收。返回了一个地址，使得没有调用Node构造函数的必要。<br>但在外部看来，我们从一个地址(我们不知道该地址是否有效)解引用(在这里，解引用本身就是危险的！)取得了一个对象，该对象的作用域在我的栈上，当栈结束时，当然应该析构。这样，加起来就调用了两次。</p>
</blockquote>
<p>虽然我的编译器做了这样(右值引用)的优化，但是这是聪明的编译器才会做的，笨蛋编译器不会优化，他们会诚实地申请空间，拷贝对象，再析构栈对象，再返回新构造的对象。这样显然效率很低。因此：<br><strong>建议：</strong> 不要返回大对象(数组或自定义对象)，如果编译器没有右值引用，申请空间并拷贝开销很大。请用参数传入指针或数组的方法返回结果。\</p>
<h3 id="返回结果可能是左值"><a href="#返回结果可能是左值" class="headerlink" title="返回结果可能是左值"></a>返回结果可能是左值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str, string::size_type idx)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回idx处值的引用</span></span><br><span class="line">    <span class="keyword">return</span> str[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">get_val</span>(s, <span class="number">0</span>)=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回列表初始化"><a href="#返回列表初始化" class="headerlink" title="返回列表初始化"></a>返回列表初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">get_string</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;;<span class="comment">// 这是被允许的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>只有函数形参列表构成重载，<strong>不能根据返回值重载！</strong><br>const的重载：<br><strong>顶层const不能重载(是否为常指针或常量)，底层const(指向的是常量)可以重载.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ret_val</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ret_val</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num)</span></span>; <span class="comment">// 不构成重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ret_val</span><span class="params">(<span class="type">int</span> *num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ret_val</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *num)</span></span>;<span class="comment">// 可以重载</span></span><br></pre></td></tr></table></figure>

<p>注意，如果同时定义了引用与常量引用，指针与const指针的两类函数，此时，规则“使用实参初始化形参时，会忽略顶层const。”，不再发挥作用。变量会调用变量版本，const会调用const版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_msg</span><span class="params">(<span class="type">int</span> &amp;num)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;normal show_msg with &quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_msg</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;const int show_msg with &quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">42</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> val=<span class="number">88</span>;</span><br><span class="line">    <span class="built_in">show_msg</span>(num);</span><br><span class="line">    <span class="built_in">show_msg</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// normal show_msg with 42</span></span><br><span class="line"><span class="comment">// const int show_msg with 88</span></span><br></pre></td></tr></table></figure>

<p>如果注释掉常量版本，又回到之前省略形参const的时候了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int show_msg with 42</span><br><span class="line">const int show_msg with 88</span><br></pre></td></tr></table></figure>

<h3 id="const-cast与重载：格外有用"><a href="#const-cast与重载：格外有用" class="headerlink" title="const_cast与重载：格外有用"></a>const_cast与重载：格外有用</h3><p>我们常常需要为参数的const版本和非const版本提供重载，这里提供一个绝佳的实践：让非const版本调用const版本，并通过const_cast增减const。</p>
<blockquote>
<p>这里也说明了const_cast的作用并不仅仅是减去const，它同样可以追加const。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个string对象的长度，返回较短的</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>()? s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非const版本，通过const_cast加减const并调用const版本</span></span><br><span class="line"><span class="function">string &amp;<span class="title">shorter</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里也可以写作 auto &amp;r=...</span></span><br><span class="line">    <span class="type">const</span> string &amp;r=<span class="built_in">shorter</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1), <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是const_cast的绝佳使用，也说明强制类型转换并不总是坏的。  </p>
</blockquote>
<h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>只出现在声明式中，多次声明对同一个形参只能配置一次默认实参。  </p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>inline是对编译器的一个请求，编译器可以选择忽略这个请求。  </p>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><p>能用于常量表达式的函数。<br>函数的返回值和形参必须是字面值类型（包括算术类型，引用和指针）（不包括自定义类，string等）。<br>constexpr函数的返回值不一定是常量表达式，如果将它赋值给constexpr，编译器会为你提供检查。  </p>
<h3 id="为什么将inline与constexpr函数定义在头文件中？"><a href="#为什么将inline与constexpr函数定义在头文件中？" class="headerlink" title="为什么将inline与constexpr函数定义在头文件中？"></a>为什么将inline与constexpr函数定义在头文件中？</h3><ul>
<li>必要知识</li>
</ul>
<p>inline与constexpr函数都是编译期函数。<br>编译期函数理论上(即按照标准)可以被定义多次，但是多次定义的内容必须完全相同。  </p>
<blockquote>
<p>实际不行，如果你尝试复制一个肯定会被展开的inline函数(甚至通过__attribute__((always_inline))保证一定展开)，GNU还是会告诉你重定义的，别想钻空子…编译器比你狡猾多了</p>
</blockquote>
<p>我们很少将非编译期函数定义在头文件中，因为如果这个头文件被多次包含，就会出现重定义的问题。  </p>
<ul>
<li>正文</li>
</ul>
<p>现在，我们希望一个函数被多个cpp文件使用，并且希望它被内联展开，此时，在头文件中做该函数的声明，并在某一个cpp文件中进行该函数的实现，这样的做法，能达到我们的目的吗？<br>答案是不能。inline是编译期的，如果编译器不能立即知道函数的实现(定义)，而要等到链接器阶段才能链接到函数实现。那假设编译器决定对该函数在定义文件中内联展开，你在别的地方对该inline函数的调用将undefined reference。<br>如果它没有被展开，那你定义inline也就没啥用…</p>
<blockquote>
<p>按照标准，应该是这样解释的。但是在GNU中，即使它最终没有被展开（例如通过inline __attribute__((noinline))阻止）或者使用O2以下的优化(不含)，你依然会得到undefined reference。  </p>
</blockquote>
<blockquote>
<p>因此，extern地利用inline函数，实际上是被GNU阻止的。即使加extern都没用。  </p>
</blockquote>
<p>为什么会这样？<br><strong>分开编译，一起链接。</strong> 编译器总是分别编译各个cpp文件，让链接器将他们链接起来。现在，你在func.cc中定义了一个inline函数（而不是头文件），并在main.cc中include func.h，并调用inline函数。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">a_inline_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// func.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">a_inline_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a inline func msg&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">a_inline_func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理器为main.cc引入了inline函数的声明，编译器编译了main.cc，它发现inline函数的声明，并期待链接器能找到一个函数实现。<br>编译器编译了func.cc函数，发现有函数是inline的，决定对它做inline展开，它在它当前能获取的范围内（即本cpp文件内）展开了该函数，<strong>并不保存该函数的实现体</strong>。<br>链接器开始链接两个cc文件的实现，main.cc要求inline函数的实现，但是链接器已经不能在func.cc中找到实现了。（因为被展开了。）<br>这就会导致链接器抛出undefined reference。<br>如果你希望定义的函数只在本cpp文件中使用，像一般函数一样，写在本cpp文件中，声明static即可。<br>对同为编译期作用的constexpr，情况是一样的。</p>
<h3 id="为什么最好不要单独使用inline，而要static-inline？"><a href="#为什么最好不要单独使用inline，而要static-inline？" class="headerlink" title="为什么最好不要单独使用inline，而要static inline？"></a>为什么最好不要单独使用inline，而要static inline？</h3><blockquote>
<p>本节只是给出一种可能性的说明，以说明为何static inline是最佳实践。GNU在实现时做了更复杂的策略，使得本节的理论无法进行实验。</p>
</blockquote>
<blockquote>
<p>我们只能说，static inline增加了inline被展开的可能。（因为杜绝了extern调用）。事实上，如上节所述，GNU本来就是阻止extern地调用inline的。你加上static，不会有任何损失。</p>
</blockquote>
<blockquote>
<p>不要小看编译器。</p>
</blockquote>
<blockquote>
<p>本节是笔者写的，不一定是对的。</p>
</blockquote>
<p>看了上一节，我们决定将inline函数的实现体放在.h文件中，这样，它被内联展开了吗？<br>答案是有可能没有，但等等，这不是因为它可能太复杂，不便inline，而是因为它可能是extern的。  </p>
<p>inline是对编译器的建议，编译器可以不接受它。如果一个inline函数不是static的，意味着用户可能在extern作用域引用它，假如我(编译器)选择将这个函数inline了，那可能的extern还怎么获取这个函数的定义？我(编译器)当然不能背这个锅！所以，对于一切不是static的inline，对编译器而言的最简单策略是，都不进行inline。  </p>
<blockquote>
<p>参考GNU文件6.39 <a target="_blank" rel="noopener" href="https://web.mit.edu/rhel-doc/3/rhel-gcc-en-3/inline.html">An Inline Function is As Fast As a Macro</a></p>
</blockquote>
<blockquote>
<p>When an inline function is not static, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-static inline function is always compiled on its own in the usual fashion.</p>
</blockquote>
<blockquote>
<p>如果参考这个文档里的说明，单独的inline将永远不会被展开，但这是违反事实的，GNU并没有那么笨，(如果它很笨就好了，方便我们的实验)。笔者做了实验，单纯的inline是可能被展开的。</p>
</blockquote>
<blockquote>
<p>我们来考虑一下，什么情况下，inline关键字可以被单独使用，以说明为什么你应该永远使用static inline。</p>
</blockquote>
<blockquote>
<p>如果实现体在头文件中（多文件使用），你写下inline，说明你希望被内联展开，此时加static将增加它被内联的概率（如果编译器决定为了extern考虑，不展开所有非static的inline得话）  </p>
</blockquote>
<blockquote>
<p>如果实现体在cc文件中（只有本文件使用），你可以单独使用inline了，此时编译器可能展开，或者不展开该inline函数。<br>此时有个不懂inline的程序员看到了你的代码，他发现你的inline函数不是static的，他决定在他新增的代码文件中直接使用该函数。(因为他没有被static声明，是extern的！)。假如编译器展开了你的inline函数，这个可怜的人将会发现undefined reference！但他不明白，这不是extern的吗？<br>如果编译器没有展开，并允许extern调用了，那更糟糕，他会认为inline的函数都是可以extern使用的，假设有一天公司换了编译器，新编译器决定对你的函数进行inline展开了（或者不允许inline的extern调用了），将会出现undefined reference…<br>而如果你一开始就写下static inline，暗示该程序员，别xjb用我的内部函数，也许就不会出现这这样的问题了。</p>
</blockquote>
<p>综上所述，你亘古不变地应该使用static inline，没有例外！  </p>
<blockquote>
<p>有一个例外，你在声明一个类的成员函数，且希望它被内联。你不能将它声明为static的，这将使它成为类函数而失去this指针。  </p>
</blockquote>
<blockquote>
<p>或者你可以在函数附近写下注释：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 别在外部使用这个函数！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">My_inline_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样也能满足你单独使用inline保留字的(奇怪)欲望…</p>
</blockquote>
<ul>
<li>附带</li>
</ul>
<p>如果你想确定一个函数是否被内联展开了，添加编译参数-save-temps&#x3D;obj，这将保留预处理器结果.ii，编译器结果.s，链接结果.o。<br><strong>注意：</strong> 只有使用-O2以上的优化(含)时，才会进行内联展开。  </p>
<h3 id="assert与调试"><a href="#assert与调试" class="headerlink" title="assert与调试"></a>assert与调试</h3><p>assert定义在头文件cassert中，是一种预处理宏，它在debug中被开启，用于检测用户定义的程序执行情况是否符合预期。<br>assert依赖于NDEBUG预处理变量，如果定义了NDEBUG，assert将什么也不做。<br>当开启release时，就开启了NDEBUG。<br>借助这个预处理变量，你也可以写一些只在debug时执行的代码。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line"><span class="comment">// __func__是编译器定义的局部静态变量，用于保存当前函数的名字</span></span><br><span class="line">cerr&lt;&lt;__func__&lt;&lt;endl;</span><br><span class="line"><span class="comment">// __FILE__ 保存文件名</span></span><br><span class="line"><span class="comment">// __LINE__ 保存当前行号</span></span><br><span class="line"><span class="comment">// __TIME__ 保存文件编译时间</span></span><br><span class="line"><span class="comment">// __DATE__ 保存文件编译日期</span></span><br></pre></td></tr></table></figure>

<h3 id="选择哪个重载函数"><a href="#选择哪个重载函数" class="headerlink" title="选择哪个重载函数"></a>选择哪个重载函数</h3><p>由于重载和函数默认值的提供，匹配调用与函数重载的逻辑是比较复杂的，大体上是匹配最优的或最接近的。<br>但有时候还是会出现重载二义性，即编译器无法决定使用哪个函数。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针指向的是函数而非对象。<br>函数指针具备某种类型，类型由函数的返回值和形参类型共同决定，与函数名无关。<br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">length_compare</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;); </span><br><span class="line"><span class="comment">// 这样就能声明一个函数指针</span></span><br><span class="line"><span class="comment">// pf两端的括号必不可少，否则它将成为函数定义。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以直接将函数名赋给指针</span></span><br><span class="line">pf = length_compare;</span><br><span class="line"><span class="comment">// 或者取函数地址</span></span><br><span class="line">pf = &amp;length_compare;</span><br><span class="line"><span class="comment">// 或者nullptr/0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 可以直接使用函数指针调用</span></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"><span class="comment">// 或者解引用调用</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>你可以将函数指针作为函数参数使用，这就是C++将函数视为对象的方法</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与数组类似，直接传入一个函数是可以的，它会被视为指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">(<span class="type">bool</span> pf(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="comment">// 或者传入一个指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">(<span class="type">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br></pre></td></tr></table></figure>

<p>写这样冗长的声明太糟糕了，可以替换为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意decltype返回的是函数，*必不可少</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(length_compare)</span> *Func</span>; </span><br><span class="line"><span class="comment">// 将exec重定义为：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">(Func fucn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接写成：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">(<span class="keyword">decltype</span>(length_compare) func)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">(<span class="keyword">decltype</span>(length_compare) *func)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">exec</span>(length_compare);</span><br></pre></td></tr></table></figure>

<ul>
<li>作为返回值（返回一个函数指针）<br>定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>);  <span class="comment">//F是函数类型，不是函数指针类型</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span> *, <span class="type">int</span>); <span class="comment">//PF是函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">ret_ptr</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 或:(不推荐这一写法)</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">ret_ptr</span>())(<span class="type">int</span>*, <span class="type">int</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>根据定义方法的不同，调用方法也有不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或者不使用using：</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*, <span class="type">int</span>);</span><br><span class="line"><span class="comment">// 更清晰的写法是</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针的最佳实践</strong>  </p>
<blockquote>
<p>这是笔者本人提供的。</p>
</blockquote>
<p>同时有typedef和using，可以起别名或者不使用别名，函数指针的语法规范是难解的。<br>为了更好的可读性，这里提供一种最佳实践：<br>使用using定义函数别名，并始终使用该函数别名。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个接受两个int，返回一个int的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_bigger</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义别名</span></span><br><span class="line"><span class="comment">// 如果存在已有函数</span></span><br><span class="line"><span class="keyword">using</span> Func=<span class="keyword">decltype</span>(get_bigger);</span><br><span class="line"><span class="comment">// 如果不存在一个已有函数</span></span><br><span class="line"><span class="keyword">using</span> Func=<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在对Func别名的三种使用：</span></span><br><span class="line"><span class="comment">// 作为函数形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">(Func* func)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 作为函数返回值</span></span><br><span class="line"><span class="function">Func* <span class="title">get_func_ptr</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 构造实参, &amp;可加可不加.</span></span><br><span class="line">Func* func_ptr=&amp;get_bigger;</span><br></pre></td></tr></table></figure>

<h2 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>与python的self一样，this是指向当前对象的指针，可以在C++类定义内部使用。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Counter</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;nums += <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 在栈上创建对象的方法与python一样，只是多一个类型</span></span><br><span class="line">Counter counter = <span class="built_in">Counter</span>();</span><br><span class="line"><span class="comment">// new创建</span></span><br><span class="line">Counter *counter_ptr = <span class="keyword">new</span> <span class="built_in">Counter</span>();</span><br><span class="line"><span class="keyword">delete</span> counter_ptr;</span><br><span class="line">counter_ptr=<span class="literal">nullptr</span>;<span class="comment">// 这样回收指针指向的空间，不是delete *counter_ptr;</span></span><br><span class="line"><span class="comment">// delete后面是地址。</span></span><br></pre></td></tr></table></figure>

<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>const成员函数禁止修改类的数据成员，通过后置const声明。<br>如果一个成员函数不进行对数据成员的修改，你就应该将它声明为const成员函数。例如一些打印信息的方法。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Counter</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">// 加在函数参数列表之后</span></span><br><span class="line">  <span class="comment">// 此时修改this-&gt;nums是非法的</span></span><br><span class="line">  <span class="comment">// 注意是const后置而不是前置，前置将是成员函数返回值的一部分。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">this</span>-&gt;nums += <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将add声明为一个const成员函数非我们所愿，优化为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Counter</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>&#123; <span class="keyword">this</span>-&gt;nums += <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_nums</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;nums;&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>常量对象，常量对象的引用，指向常量对象的指针，都只能调用const成员函数。<br>const成员函数，或者不是const的成员函数，可以以此进行函数重载。  </p>
<h3 id="在类的外部定义函数"><a href="#在类的外部定义函数" class="headerlink" title="在类的外部定义函数"></a>在类的外部定义函数</h3><p>成员函数的声明一定要在类体内，但可以在外部定义。<br>规范是：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 类名::方法名(方法参数列表) [const]&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Counter::get_nums</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回this"><a href="#返回this" class="headerlink" title="返回this"></a>返回this</h3><p>可以让add方法返回this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Counter&amp; <span class="title">Counter::add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nums+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这方便于连续调用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter.<span class="built_in">add</span>().<span class="built_in">add</span>().<span class="built_in">add</span>();</span><br></pre></td></tr></table></figure>

<p>返回引用对于连续调用方法是必须的，如果返回值是Counter，相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将创建对counter的浅拷贝</span></span><br><span class="line">Counter tmp = counter.<span class="built_in">add</span>();</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数不能是const的。<br>如果定义了一个构造函数，编译器就不会生成默认构造函数。最佳实践是，总是显式地定义构造函数，即使什么也不做。  </p>
<blockquote>
<p>如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。  </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快捷显式定义构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用初始化列表</li>
</ul>
<p>初始化参数列表是被effective推荐的最佳实践，这将只有初始化一个开销。<br>如果你使用赋值的方法，需要先进行初始化，再进行赋值，开销比较大。<br>对const数据成员，只能通过初始化参数列表进行初始化，而不能通过在构造函数中赋值。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 语法：</span></span><br><span class="line">    <span class="comment">// 类名(形参列表):属性1(形参1), 属性2(形参2)...&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 形参可以与实参的名字相同或不同，编译器能正确区分他们.</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string name, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> age, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> id, <span class="type">float</span> score) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age), <span class="built_in">number</span>(id), <span class="built_in">score</span>(score) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> std::string name;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝、幅值与析构"><a href="#拷贝、幅值与析构" class="headerlink" title="拷贝、幅值与析构"></a>拷贝、幅值与析构</h3><p>编译器会生成默认的拷贝赋值与析构函数，但默认的函数并不总是有效的，尤其在类内存在动态内存分配时，要保证正确地回收对象的内存，必须自行定义析构函数。<br>在需要深拷贝的情况下，默认的拷贝构造函数也不能作用。<br>TODO：等待后续补充。</p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>除了语法,struct与class唯一的区别在于struct的默认权限是public的,class则是private的。  </p>
<blockquote>
<p>在C++中，不需要使用struct。</p>
</blockquote>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>我们希望我们定义的一些函数能否访问类的私有成员或函数，可以将这些外部函数声明为友元函数。  </p>
<blockquote>
<p>不要这么做，这在破坏封装性.  </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show_info</span><span class="params">(<span class="type">const</span> Student* ptr)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> std::string name;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_info</span><span class="params">(<span class="type">const</span> Student* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;\n name:&quot;</span> &lt;&lt; ptr-&gt;name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; ptr-&gt;age &lt;&lt; <span class="string">&quot; number:&quot;</span> &lt;&lt; ptr-&gt;number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>与友元函数类似，这将允许友元类访问本类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show_info</span><span class="params">(<span class="type">const</span> Student* ptr)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;\n name:&quot;</span> &lt;&lt; ptr-&gt;name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; ptr-&gt;age &lt;&lt; <span class="string">&quot; number:&quot;</span> &lt;&lt; ptr-&gt;number &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>;</span><br><span class="line">    <span class="comment">// 可以只赋予teacher的show_info方法友元权限，但这要求方法必须先声明。</span></span><br><span class="line">    <span class="comment">// friend void Teacher::show_info(const Student*);</span></span><br><span class="line">    <span class="comment">// 如果要赋予友元的函数进行了重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> std::string name;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="内联的成员函数"><a href="#内联的成员函数" class="headerlink" title="内联的成员函数"></a>内联的成员函数</h3><p>如果一个成员函数不是类成员函数，那应该使用inline而不是static inline，static声明将使得函数失去this指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> number, string name):<span class="built_in">number</span>(number),<span class="built_in">name</span>(name)&#123;&#125;</span><br><span class="line">        <span class="comment">// it&#x27;s ok</span></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">show_info</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;number:&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;number&lt;&lt;<span class="string">&quot; name:&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// illegal:class function don&#x27;t have this ptr;</span></span><br><span class="line">        <span class="comment">// static inline void show_info()&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&quot;number:&quot;&lt;&lt;this-&gt;number&lt;&lt;&quot; name:&quot;&lt;&lt;this-&gt;name&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">        string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>当你希望一个数据成员可以被const成员函数修改时，将它声明为mutable的。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> number, string name):<span class="built_in">number</span>(number),<span class="built_in">name</span>(name)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(std::string new_name)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name=new_name;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">        <span class="keyword">mutable</span> string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类成员初始值"><a href="#类成员初始值" class="headerlink" title="类成员初始值"></a>类成员初始值</h3><p>希望为类的数据成员提供初始值时，必须使用&#x3D;或花括号{}。<br>这是说，你不能使用()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// error:</span></span><br><span class="line">        <span class="comment">// string name(&quot;Node&quot;);</span></span><br><span class="line">        string name&#123;<span class="string">&quot;name&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>构造函数将部分构造功能委托给另一个构造函数，这就是委托构造函数。<br>用在提供多种构造函数时，存在部分数据成员的初始化方法相同。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(string name, <span class="type">int</span> num):<span class="built_in">name</span>(name), <span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">        <span class="built_in">Node</span>(string name):<span class="built_in">Node</span>(name, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">// 但是，这可以通过给上一个构造函数默认值来完成...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="转换构造函数与隐式的类类型转换"><a href="#转换构造函数与隐式的类类型转换" class="headerlink" title="转换构造函数与隐式的类类型转换"></a>转换构造函数与隐式的类类型转换</h3><p>如果一个构造函数只定义了一个参数，那它实际上是一个转换构造函数。<br>这十分有用，在函数要求类型时，可以将那个参数的类型给进去。  </p>
<blockquote>
<p>这也帮助我们理解隐式转换的实质，只不过是构造函数而已，编译器帮你顺手做了一下构造。  </p>
</blockquote>
<blockquote>
<p>这也解释了为何有时不能进行隐式转换，必须进行显示转换：要转换到的类，没有提供对应的单参数构造函数（转换构造函数。）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(string name):<span class="built_in">name</span>(name)&#123;&#125;</span><br><span class="line">        string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_name</span><span class="params">(<span class="type">const</span> Node &amp;node)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;node.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s&#123;<span class="string">&quot;我下午要玩戴森球计划&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">show_name</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用explicit阻止隐式的类型转换"><a href="#使用explicit阻止隐式的类型转换" class="headerlink" title="使用explicit阻止隐式的类型转换"></a>使用explicit阻止隐式的类型转换</h3><p>很多时候我们不想单参数的构造函数用作转换构造函数，即，我们不希望隐式地创建对象。要阻止编译器为你做这样的转换工作，在<strong>声明</strong>单参数构造函数时，添加explicit声明。<br>Note：</p>
<ul>
<li>explicit只对单参数构造函数有用。</li>
<li>只能放在函数声明处，不能放在定义处。</li>
<li>如果在声明处定义，也ok。</li>
<li>explicit不会阻止显式的构造或强制类型转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(string name)</span>:name(name)&#123;</span>&#125;</span><br><span class="line">        string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_name</span><span class="params">(<span class="type">const</span> Node &amp;node)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;node.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s&#123;<span class="string">&quot;我下午要玩戴森球计划&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="comment">// show_name(s);</span></span><br><span class="line">    Node node = <span class="built_in">Node</span>(s);</span><br><span class="line">    <span class="built_in">show_name</span>(node);</span><br><span class="line">    <span class="built_in">show_name</span>(<span class="built_in">Node</span>(s));</span><br><span class="line">    <span class="comment">// 但是允许显式的强制类型转换</span></span><br><span class="line">    <span class="built_in">show_name</span>(<span class="built_in">static_cast</span>&lt;Node&gt;(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换构造函数允许一步转换，但是不会允许多步转换。假设有一个函数需要std::string，你可以用字面值const char*来作为实参。<br>我们上面例子的show_name接受Node类型，如果没有explicit声明，它可以接受一个std::string，但是不能接受一个const char* 字面量。那就是两步转换了。  </p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>允许用户直接访问其成员，且具备特殊的初始化语法。满足以下特点：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有virtual函数。</li>
</ul>
<blockquote>
<p>不必记忆它不是什么，最好记忆它是什么。聚合类表现为一组数据成员的组合，可以通过花括号{}进行初始化。  </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者使用struct,好处很明显，你不用打public了。</span></span><br><span class="line"><span class="comment">// 这可能是struct唯一在c++的作用。</span></span><br><span class="line">Data data = &#123;<span class="string">&quot;pudding&quot;</span>, <span class="number">114514</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a>constexpr构造函数</h3><p>构造函数可以用constexpr修饰，随后，它必须初始化所有数据成员。  </p>
<blockquote>
<p>弄不懂何时使用。</p>
</blockquote>
<p>TODO:constexpr构造函数</p>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>类的静态成员函数不能获取this指针，也不能被声明为const的。<br>可以通过对象或类来访问静态成员。<br>静态成员在类内是直接可见的，不用通过this等访问。  </p>
<p>可以在类的内外定义静态成员函数，但在外部定义时，不能重复static关键词。（就像你不能重复explicit关键词一样）<br>你不能在类内直接为一个static数据成员初始化，除非它是const的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Node::id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>静态成员可以作为默认实参，但对象的成员不可以，因为对象的成员属于对象。  </p>
<h1 id="第Ⅱ部分：C-标准库"><a href="#第Ⅱ部分：C-标准库" class="headerlink" title="第Ⅱ部分：C++标准库"></a>第Ⅱ部分：C++标准库</h1><h2 id="第八章：IO库"><a href="#第八章：IO库" class="headerlink" title="第八章：IO库"></a>第八章：IO库</h2><h3 id="三种IO流类型"><a href="#三种IO流类型" class="headerlink" title="三种IO流类型"></a>三种IO流类型</h3><ul>
<li>iostream IO流</li>
<li>fstream 文件流</li>
<li>sstream 字符串流</li>
</ul>
<p>宽字符(wchar_t)使用的是wcin, wcout和wcerr。</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>读写文本文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">in</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;<span class="comment">// ifstream也可以</span></span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>; <span class="comment">// ofstream打开，覆盖写,如果是fstream打开，则不清空，光标从0号位置开始写。</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, s))&#123;</span><br><span class="line">        out&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于ofstream打开文件时一定会清空文件，因此追加写需要显式指定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">in</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>, ofstream::app)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, s))&#123;</span><br><span class="line">        out&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件流常用三个方法：</p>
<ul>
<li>fstream.open(“filename.txt”)</li>
<li>fstream.good() 或fstream.is_open()</li>
<li>fstream.close()</li>
</ul>
<h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><p>如果希望将自定义结构的数据保存到外存的二进制文件中，那么自定义结构不能包含可变长度类型，例如各种stl容器。  </p>
<p>下面的例子就要求结构体Student的char数组是固定长度的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;out_bin.bin&quot;</span>, ofstream::binary)</span></span>;</span><br><span class="line">Student ns=&#123;<span class="string">&quot;大BOSS&quot;</span>, <span class="number">18</span>, <span class="number">1001</span>&#125;;</span><br><span class="line">out.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;ns), <span class="built_in">sizeof</span>(ns));</span><br><span class="line">out.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;out_bin.bin&quot;</span>, ifstream::binary)</span></span>;</span><br><span class="line">Student ns;</span><br><span class="line">in.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;ns), <span class="built_in">sizeof</span>(ns));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">&#125;;<span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">&#125;;<span class="comment">// core.</span></span><br></pre></td></tr></table></figure>

<h3 id="使用字符串流sstream"><a href="#使用字符串流sstream" class="headerlink" title="使用字符串流sstream"></a>使用字符串流sstream</h3><p>sstream有好处：由于流的特点，可以简单地用空格分割，并将他们赋予不同的变量，以下是一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;BigBoss 22 2022&quot;</span>)</span></span>;</span><br><span class="line">    string name, year;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    ss&gt;&gt;name&gt;&gt;age&gt;&gt;year;</span><br><span class="line">    cout&lt;&lt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stringstream相当于fstream，也可以用istringstream或ostringstream。<br>sstream的方法：</p>
<ul>
<li>strm.str(); 返回sstream返回中的字符串。</li>
<li>strm.str(“some string”); 将string绑定给流，返回void;</li>
</ul>
<h2 id="第九章：顺序容器"><a href="#第九章：顺序容器" class="headerlink" title="第九章：顺序容器"></a>第九章：顺序容器</h2><h3 id="顺序容器类型与特点"><a href="#顺序容器类型与特点" class="headerlink" title="顺序容器类型与特点"></a>顺序容器类型与特点</h3><table>
<thead>
<tr>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>可变大小；随机访问；尾部操作快</td>
</tr>
<tr>
<td>deque</td>
<td>双向队列;随机访问；头尾操作快</td>
</tr>
<tr>
<td>list</td>
<td>双向链表;双向顺序访问；任何位置操作都快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单项列表；单向顺序访问；任何位置都快</td>
</tr>
<tr>
<td>array</td>
<td>固定大小；随机访问；不能增减元素；</td>
</tr>
<tr>
<td>string</td>
<td>与vector类似，专注于保存字符；尾部操作快</td>
</tr>
</tbody></table>
<p><strong>使用建议</strong>:</p>
<ul>
<li>一般情况下，vector一把梭。</li>
<li>链表(list&#x2F;forward_list)的空间占用较大，避免在空间敏感时使用。</li>
<li>deque也很常用。</li>
</ul>
<h3 id="所有容器都支持的操作"><a href="#所有容器都支持的操作" class="headerlink" title="所有容器都支持的操作"></a>所有容器都支持的操作</h3><ul>
<li>容器都定义在与它的名字一样的头文件中，如deque定义在deque头文件中。</li>
<li>容器都是模板类，在声明时需要给出d_type；box&lt;d_type&gt;</li>
</ul>
<p><strong>构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Box box; <span class="comment">//空容器</span></span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(b2)</span></span>; <span class="comment">//拷贝构造，深拷贝</span></span><br><span class="line">B b1=b2; <span class="comment">//初始化，深拷贝</span></span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(s, e)</span></span>; <span class="comment">//将迭代器s和e范围内的元素拷贝到b3中</span></span><br><span class="line">B b4&#123;a,b,c...&#125;; <span class="comment">// 列表初始化</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>令人吃惊的是，容器类的()与&#x3D;构造都是深拷贝，且是完全的深拷贝。即对于d_type为自定义类型，且类型内包含传统数组的情况，也会支持深拷贝。非常可靠。</p>
</blockquote>
<p><strong>常用方法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">swap</span>(b); <span class="comment">//交换a,b容器的元素</span></span><br><span class="line"><span class="comment">// or swap(a, b)</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增删元素</span></span><br><span class="line">c.<span class="built_in">insert</span>(args); <span class="comment">// 拷贝args进c里。</span></span><br><span class="line"><span class="comment">// 对于vector: v.insert(v.begin(), 12345); 第一个参数是const迭代器</span></span><br><span class="line">c.<span class="built_in">erase</span>(args); <span class="comment">// 删除指定元素</span></span><br><span class="line"><span class="comment">// 常见两个重载，v.erase(v.begin()+i) or v.erase(v.begin(), v.end());</span></span><br><span class="line">c.<span class="built_in">clear</span>(); <span class="comment">// 清空</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">front</span>();<span class="comment">// 返回首元素的引用。除了array都有</span></span><br><span class="line">c.<span class="built_in">back</span>();<span class="comment">//返回尾元素的引用，除了forward_list都有。</span></span><br><span class="line"><span class="comment">// 因为是引用，所以front和back都可以作为左值使用.</span></span><br><span class="line"><span class="comment">// 两个方法对空都是不安全的，属于未定义行为。</span></span><br></pre></td></tr></table></figure>

<h3 id="容器的迭代器"><a href="#容器的迭代器" class="headerlink" title="容器的迭代器"></a>容器的迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>(); <span class="comment">// 反向迭代器，从最后一个元素开始，使用++访问上一个元素</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>(); <span class="comment">// const迭代器，不允许修改元素;</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>(); <span class="comment">// 反向const迭代器</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序容器支持的操作"><a href="#顺序容器支持的操作" class="headerlink" title="顺序容器支持的操作"></a>顺序容器支持的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array不支持这些操作</span></span><br><span class="line"><span class="comment">// forward_list 有自己专属版本的insert和emplace;</span></span><br><span class="line"><span class="comment">// forward_list 不支持push_back和emplace_back;</span></span><br><span class="line"><span class="comment">// vector和string 不支持 push_front和emplace_front</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">push_back</span>(t); <span class="comment">// 除了array和forward_list外，每个顺序容器都支持push_back；包括string。</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11新支持了emplace系方法. push_back在添加元素前会先创建这个元素，再将元素移动到容器中，而emplace_back添加元素时，是直接在尾部创建这个元素，相对来说效率更高。</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(t);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(p, t);<span class="comment">// insert方法返回指向p位置的迭代器.</span></span><br><span class="line"><span class="comment">//因此可以放在循环里，不断向特定位置插值</span></span><br><span class="line">c.<span class="built_in">emplace</span>(p, t);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">push_front</span>(t)<span class="comment">// list, forward_list, deque支持front追加。forward_list顾头不顾尾.</span></span><br><span class="line"><span class="comment">// vector充当了栈，deque则两头.</span></span><br></pre></td></tr></table></figure>

<h3 id="emplace与push的性能讨论"><a href="#emplace与push的性能讨论" class="headerlink" title="emplace与push的性能讨论"></a>emplace与push的性能讨论</h3><p>emplace 比 push省去了拷贝这一步，但如果对象是已经创建好的，则效率是一致的。<br>只有在触发转换构造函数，或者C++内置类型时，会有较大的收益。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> n):<span class="built_in">num</span>(n)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">const</span> Node &amp;other):<span class="built_in">num</span>(other.num)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Node</span>(Node&amp;&amp; old):<span class="built_in">num</span>(old.num)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;移动构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Node&gt; vns;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;效率相等的情况：先创建对象，再放入容器&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;push_back:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vns.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">12</span>));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------\n&quot;</span>&lt;&lt;<span class="string">&quot;emplace_back:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vns.<span class="built_in">emplace_back</span>(<span class="built_in">Node</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------\nemplace_back效率高的情况：\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;push_back:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vns.<span class="built_in">push_back</span>(<span class="number">12</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;emplace_back:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vns.<span class="built_in">emplace_back</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">效率相等的情况：先创建对象，再放入容器</span><br><span class="line">push_back:</span><br><span class="line">构造函数</span><br><span class="line">移动构造函数</span><br><span class="line">------</span><br><span class="line">emplace_back:</span><br><span class="line">构造函数</span><br><span class="line">移动构造函数</span><br><span class="line">拷贝构造函数</span><br><span class="line">---------</span><br><span class="line">emplace_back效率高的情况：</span><br><span class="line">push_back:</span><br><span class="line">构造函数</span><br><span class="line">移动构造函数</span><br><span class="line">拷贝构造函数</span><br><span class="line">拷贝构造函数</span><br><span class="line">emplace_back:</span><br><span class="line">构造函数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一种情况让人感到费解，emplace_back多调用了一次拷贝构造函数。它的效率比push_back更低了。  </p>
</blockquote>
<blockquote>
<p>第二种情况当然是符合期望的，也是emplace_back能大幅取得收益的地方。  </p>
</blockquote>
<blockquote>
<p>因此，不能说emplace_back总比push_back好。事实上，除非你能通过定义转换的形式(单参数ok，多参数也ok)，保证emplace_back更好，否则还是push_back一把梭吧。</p>
</blockquote>
<h3 id="使用resize"><a href="#使用resize" class="headerlink" title="使用resize"></a>使用resize</h3><p>可以使用resize调整容器的大小，向其中加入指定元素来填充，或删除部分元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">resize</span>(n) <span class="comment">//将c的大小调整为n，超过则删除后面的，不足则用0补齐。</span></span><br><span class="line">c.<span class="built_in">resize</span>(n, num)<span class="comment">// 不足用num补齐。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>resize是有些危险的，如果缩小容器，可能导致指向被删除元素的迭代器，引用和指针失效。</p>
</blockquote>
<p>使用指向容器类型的指针是危险的，如果容器增加或删除了元素，引起了存储空间的重新分配，指针可能会失效。</p>
<blockquote>
<p>这么说，为什么我们当时使用的vector都使用了shared_ptr呢？</p>
</blockquote>
<blockquote>
<p><strong>警告</strong>：不要保存end返回的迭代器。对容器的任何添加或删除操作都会使得end迭代器失效。希望通过begin!&#x3D;end来遍历容器时需要在每次循环时都调用end()，而不是先保存它。</p>
</blockquote>
<h3 id="管理vector的扩张"><a href="#管理vector的扩张" class="headerlink" title="管理vector的扩张"></a>管理vector的扩张</h3><p>vector总是申请比它当前需要的元素多一些的空间，以应对随时可能到来的push_back。<br>可以使用一定的方法告知vector准备多少空间，以改善程序性能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将capacity()减少到size()大小，相当于避免占用多余的空间.</span></span><br><span class="line"><span class="comment">// 对于d_type很大，且空间敏感时，在程序的最后调用一下这个方法很好.</span></span><br><span class="line"><span class="comment">// 但这依然是一个请求，请求编译器在这里退回多余的容器空间。因为是请求，所以不一定会被执行.</span></span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">capacity</span>();<span class="comment">// 当前不引起重新内存分配的最大容量.</span></span><br><span class="line">c.<span class="built_in">reserve</span>(n);<span class="comment">// 分配n个元素的内存空间</span></span><br><span class="line"><span class="comment">// reserve会至少分配n个元素的内存空间，不过有可能更大.</span></span><br></pre></td></tr></table></figure>

<h3 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cp, n)</span></span>;<span class="comment">// cp数组中前n个元素的拷贝</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(s2, pos2)</span></span>;<span class="comment">// 对s2的，从pos2开始的元素拷贝</span></span><br><span class="line"><span class="function">stirng <span class="title">s</span><span class="params">(s2, pos2, len)</span></span>; <span class="comment">//对s2的，从pos2开始的，len个元素的拷贝</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sub_str</span></span><br><span class="line">s.<span class="built_in">substr</span>(pos, len) <span class="comment">// 注意第二个参数是len，不是pos，与切片不同！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//insert-erase</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>); <span class="comment">//末位加入5个!</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">size</span>()<span class="number">-5</span>, <span class="number">5</span>); <span class="comment">// 删除末尾的5个元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">s.<span class="built_in">assign</span>(str, <span class="number">5</span>);<span class="comment">// s=Hello；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append与replace</span></span><br><span class="line">s.<span class="built_in">append</span>(<span class="string">&quot;abcde&quot;</span>); <span class="comment">//append在末尾追加字符串,push_back只能放入一个字符.</span></span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;abcdes&quot;</span>);<span class="comment">// 从0号位置开始删除3个元素，替换为abcdes。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索</span></span><br><span class="line"><span class="comment">// 如果搜索失败，返回string::npos</span></span><br><span class="line">string s1=<span class="string">&quot;abcdes&quot;</span>;</span><br><span class="line">s1.<span class="built_in">find</span>(<span class="string">&quot;abc&quot;</span>) <span class="comment">// rst=0, 注意，这是一个unsigned!最好不要用int这样的有符号类型保存它.</span></span><br><span class="line"><span class="comment">// 推荐用auto？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找与任何字符匹配的第一个位置</span></span><br><span class="line">string res=<span class="string">&quot;abcdefg123890&quot;</span>;</span><br><span class="line">res.<span class="built_in">find_first_of</span>(<span class="string">&quot;0123456789&quot;</span>);<span class="comment">// 相当于返回第一个数字所在的索引.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找与给定字符不匹配的第一个位置</span></span><br><span class="line">res.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line">s.<span class="built_in">rfind</span>() <span class="comment">// 最后一次出现</span></span><br><span class="line">s.<span class="built_in">find_last_of</span>(); <span class="comment">//倒着找</span></span><br><span class="line">s.<span class="built_in">find_last_not_of</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例：每步循环查找字符串中的下一个数字</span></span><br><span class="line">string::size_type pos=<span class="number">0</span>;</span><br><span class="line">string s2=<span class="string">&quot;ab12cd34ef56ppos&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>((pos=s2.<span class="built_in">find_first_of</span>(<span class="string">&quot;0123456789&quot;</span>, pos))!=string::npos)&#123;</span><br><span class="line">    cout&lt;&lt;pos&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s2[pos]&lt;&lt;endl;</span><br><span class="line">    ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串的数值转换</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line">string s=<span class="built_in">to_string</span>(i);</span><br><span class="line"><span class="type">double</span> d=<span class="built_in">stod</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="built_in">to_string</span>(val);<span class="comment">// 几乎所有的内置数据类型都有</span></span><br><span class="line"><span class="built_in">stoi</span>(); <span class="comment">// int</span></span><br><span class="line"><span class="built_in">stol</span>(); <span class="comment">// long</span></span><br><span class="line"><span class="built_in">stoul</span>(); <span class="comment">//unsigned long</span></span><br><span class="line"><span class="built_in">stoll</span>(); <span class="comment">// long long</span></span><br><span class="line"><span class="built_in">stoull</span>(); <span class="comment">// unsigned long long</span></span><br><span class="line"><span class="built_in">stof</span>(); <span class="comment">// float </span></span><br><span class="line"><span class="built_in">stod</span>(); <span class="comment">//double </span></span><br><span class="line"><span class="built_in">stold</span>(); <span class="comment">// long double</span></span><br></pre></td></tr></table></figure>

<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>C++有三种容器适配器。所谓容器适配器，是指可以由容器伪装的一种类型，表现出适配器类型的特点。  </p>
<ul>
<li>stack</li>
<li>queue</li>
<li>priority_queue</li>
</ul>
<blockquote>
<p>适配器只有空构造函数，和从基础容器的构造函数。这是说，你不能通过{}来初始化他们。</p>
</blockquote>
<blockquote>
<p>不能使用auto迭代，没有begin和end方法。</p>
</blockquote>
<blockquote>
<p>从功能上，适配器是带有限制的基础容器。</p>
</blockquote>
<p><strong>stack</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不太理解什么场景会用stack。</span></span><br><span class="line"><span class="comment">// 因为vector可以完全替代它的作用.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq&#123;<span class="number">12</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">// 适配器可以用一些基本容器类型初始化</span></span><br><span class="line">    <span class="comment">// 奇怪的是，stack不能用vector初始化...</span></span><br><span class="line">    <span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">sk</span><span class="params">(deq)</span></span>; </span><br><span class="line">    sk.<span class="built_in">push</span>(<span class="number">123</span>);</span><br><span class="line">    <span class="type">int</span> top=sk.<span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br><span class="line">    sk.<span class="built_in">pop</span>(); <span class="comment">//pop没有返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>queue与priority_queue</strong></p>
<p>本节在cxx_primer中的叙述很奇怪，可能是有所错误。<br>书330页底部关于队列适配器的叙述，说q.pop()不删除元素，且有返回值，但这是不正确的。测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">que</span><span class="params">(deq)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;que.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">        que.<span class="built_in">pop</span>();<span class="comment">// 返回值是void的！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下给出优先队列的常见使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1024</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">42</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">2048</span>);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;pq.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2048</span></span><br><span class="line"><span class="comment">// 1024</span></span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>优先队列默认是从大到小的（大根堆）。<br>要声明一个小根堆，需要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pq</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>这是priority的完整声明，第一个参数是d_type，第二个是实现优先队列的底层容器类型，这里用了vector，第三个是比较两个元素之间的函数。一般有std::less和std::greater。greater代表从前到后，依次greater。</p>
<h2 id="第十章：泛型算法"><a href="#第十章：泛型算法" class="headerlink" title="第十章：泛型算法"></a>第十章：泛型算法</h2><p>本章的重点在算法，而不是对用户如何定义泛型的讲解。主要介绍定义在头文件algorithm中，以及一些数值泛型操作，定义在numeric中。  </p>
<p>但泛型算法的“泛型”也十分重要，它意味着算法并不作用于特定容器之上，在下面可以看到，泛型算法总是作用在容器的迭代器上。<br>因此，泛型算法一定不会改变容器的大小。尽管它有可能改变元素的值。  </p>
<blockquote>
<p>因为你知道，在使用迭代器遍历容器时，增删元素是危险的。</p>
</blockquote>
<h3 id="一个好的例子：find与count"><a href="#一个好的例子：find与count" class="headerlink" title="一个好的例子：find与count"></a>一个好的例子：find与count</h3><p>algorithm中的find可以作用在标准库容器或C数组上，返回一个迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// result 是一个迭代器，使用autou最好</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), val);</span><br><span class="line"><span class="comment">// count则返回出现的次数.</span></span><br><span class="line"><span class="type">int</span> rst = <span class="built_in">count</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 如果找不到result == vec.end()</span></span><br></pre></td></tr></table></figure>

<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>上面的count和find就是只读算法。同使用类型的包括：</p>
<ul>
<li>count: 统计范围内特定元素的个数.</li>
<li>find: 查找特定范围内的第一个元素.</li>
<li>accumulate: 对特定范围求和。（第三个参数是求和初始量，也决定了使用哪种加法，以及返回值类型）</li>
</ul>
<blockquote>
<p>如果你对string类型调用accumulate，那么就会造成拼接。</p>
</blockquote>
<blockquote>
<p>你不能这样写：string sum &#x3D; accumulate(v.begin(), v.end(), “”)，因为const char*上没有定义加法运算符。</p>
</blockquote>
<blockquote>
<p>你需要把它修改为string(“”).</p>
</blockquote>
<ul>
<li>equal: 比较两个容器的元素值是否完全相等。参数分别为：第一个容器的begin，第一个容器的end，第二个容器的begin。</li>
</ul>
<blockquote>
<p>equal可以从第一个容器的begin和end推测出应该遍历多少次第二个容器。因此，你需要保证第二个容器至少含有那么多元素。  </p>
</blockquote>
<h3 id="写容器元素"><a href="#写容器元素" class="headerlink" title="写容器元素"></a>写容器元素</h3><ul>
<li>fill: fill(vec.begin(), vec.end(), 0); 用第三个元素给各位置赋值。</li>
<li>fill_n: fill_n(vec.begin(), n, 0); n标志了移动多少次.</li>
</ul>
<p>fill_n要求程序员确保n位空间已申请且可访问。如果没有，那么结果是未定义的。  </p>
<h3 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h3><p>back_inserter定义在interator头文件中。它接受一个容器的引用，返回一个与该容器绑定的插入迭代器。<br>之后，给该迭代器赋值，会隐含地调用push_back()，以添加元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec)</span><br><span class="line">*it = <span class="number">42</span>;<span class="comment">// is equal to vec.push_back(42);</span></span><br></pre></td></tr></table></figure>

<p>配合使用back_inserter和fill_n，我们就可以给已经创建好的容器批量添加元素了。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec), <span class="number">10</span>, <span class="number">0</span>) <span class="comment">// 加入10个0给vec。</span></span><br></pre></td></tr></table></figure>

<h3 id="拷贝copy"><a href="#拷贝copy" class="headerlink" title="拷贝copy"></a>拷贝copy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(a1.<span class="built_in">begin</span>(), a1.<span class="built_in">end</span>(), a2.<span class="built_in">begin</span>());</span><br><span class="line"><span class="comment">// 需要用户确保a2有足够的空间</span></span><br><span class="line"><span class="comment">// 返回的ret指向a2尾元素之后的位置。</span></span><br></pre></td></tr></table></figure>

<h3 id="replace与copy"><a href="#replace与copy" class="headerlink" title="replace与copy"></a>replace与copy</h3><p>许多算法有copy版本，即不修改原先的容器，而是将结果放入第三个容器中。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般replace:</span></span><br><span class="line"><span class="built_in">replace</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="number">42</span>);<span class="comment">// 0替换为42;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy版本</span></span><br><span class="line"><span class="built_in">replace_copy</span>(a1.<span class="built_in">cbegin</span>(), a1.<span class="built_in">cend</span>(), <span class="built_in">back_inserter</span>(new_vec), <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 结果将会放到new_vec中</span></span><br></pre></td></tr></table></figure>

<h3 id="sort与unique"><a href="#sort与unique" class="headerlink" title="sort与unique"></a>sort与unique</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是一个任务：删除string数组的重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序，寻找重复单词</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unique得配合sort使用才行.将不重复的元素放到容器的前面，返回第一个重复元素的位置的迭代器。</span></span><br><span class="line"><span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">words.<span class="built_in">erase</span>(end_unique, words.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>unique的作用是去除容器或者数组中相邻元素的重复出现的元素，只保留其中一个。其函数原型为：iterator unique (iterator it_1,iterator it_2)。其中，it_1和it_2表示容器的起始和结束迭代器，函数会返回去重之后的尾地址。需要注意的是，这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾。对于顺序顺序错乱的数组成员或者容器成员，需要先进行排序，可以调用std::sort()函数。</p>
</blockquote>
<h3 id="定制行为：向算法传递函数"><a href="#定制行为：向算法传递函数" class="headerlink" title="定制行为：向算法传递函数"></a>定制行为：向算法传递函数</h3><p>标准库中的算法的行为常常是确定的，但用户也可以进行一些定制操作。</p>
<p>我们自定义一个函数，让标准库算法使用我们定义的函数工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数传递给泛型算法以定制操作</span></span><br><span class="line"><span class="comment">// sort在底层执行的是一个二元运算符，因此第三个函数被要求定义为二元的。</span></span><br><span class="line"><span class="comment">// 这个函数将words按照元素长度，从小到大排列.</span></span><br><span class="line"><span class="comment">// 即对二元的 s1和s2，如果s1 ? s2==True，则s1排在s2之前.</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure>

<p>容易理解，标准库提供的泛型算法作用在一个地址区间上的每个元素或每组元素上，本质上是元素操作。因此，一定存在运算符。<br>理解算法使用的是哪种运算符，是几元的，我们就能定制算法行为。  </p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br><span class="line"><span class="comment">// capture list指lambda函数体内会使用的“局部标识符”。</span></span><br><span class="line"><span class="comment">// 不在捕获列表内，lambda函数无法使用.</span></span><br><span class="line"><span class="comment">// 全局变量不是。lambda函数内可以使用任何全局声明的，包括函数与类定义，或者static变量。</span></span><br></pre></td></tr></table></figure>

<p>在实现时，可以忽略参数列表和返回值类型，但永远必须包含捕获列表和函数体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="comment">// 建议记忆：</span></span><br><span class="line"><span class="keyword">auto</span> f = []()&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="comment">// lambda函数不允许默认参数。</span></span><br><span class="line"><span class="comment">// labmda函数要求在定义体最后的;</span></span><br></pre></td></tr></table></figure>

<p>lambda函数的调用与一般函数一致。由于短小，方便调用，常用在传递给函数，以定制行为上。</p>
<p>之前的例子可以用lambda函数实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> shorter = [](<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vec&#123;<span class="string">&quot;123dd&quot;</span>, <span class="string">&quot;4567&quot;</span>,<span class="string">&quot;qw&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), shorter);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="comment">// sort(vec.begin(), vec.end(), [](const string &amp;s1, const string &amp;s2)&#123;return s1.size()&lt;s2.size();&#125;);</span></span><br><span class="line"><span class="comment">// ...，这种代码在大型工程中会不会有点不负责任？</span></span><br></pre></td></tr></table></figure>

<p>lambda做的实际工作比看上去更多。编译器实际上先定义了一个lambda对应的，未命名的class类型。我们调用声明的lambda函数时(包括auto的赋值调用和字面量传入函数调用)，实际上在构造这个未命名的class的对象。  </p>
<h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><p>find_if是对find的定制行为支持。<br>find只能使用&#x3D;&#x3D;完成查找操作，find_if则在第三项接受一个返回bool的函数，单目运算符，作用在每个遍历到的元素上，直到第三个参数的函数返回True为止。  </p>
<p>配合lambda表达式，实现一个找到列表中第一个达到指定长度的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; vs&#123;<span class="string">&quot;123&quot;</span>, <span class="string">&quot;abc&quot;</span>,<span class="string">&quot;45z6&quot;</span>,<span class="string">&quot;def&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> min_size = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也演示了lambda表达式关于局部变量捕获的使用方法</span></span><br><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">find_if</span>(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), [min_size](<span class="type">const</span> string &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;=min_size;&#125;);</span><br></pre></td></tr></table></figure>

<p>容易理解，如果先根据元素长度对列表排序，再find_if取得第一个达到期望长度的元素的迭代器，根据vs.end()-ptr，我们就能知道列表中有多少个元素达到了指定长度。  </p>
<blockquote>
<p>当然，这样做在时间上是亏很多的。</p>
</blockquote>
<h3 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h3><p>for_each算法接受一个可调用对象（lambda&#x2F;函数），对范围内的所有元素调用该对象。（所以，可调用对象必须是单目的）</p>
<p>下段代码打印vector&lt;string&gt;中所有字符串的反转，但不修改字符串。<br>用了两种方法，for(:)和for_each。<br>由于范围for不加&amp;时会创建元素的拷贝，因此无需额外考虑，调用reverse就能反转一个备份，然后打印。<br>for_each更像是一般的循环，自行申请了新的空间，并用reverse_copy完成了工作。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;string&gt; vs&#123;<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>, <span class="string">&quot;789&quot;</span>&#125;;</span><br><span class="line">  <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;</span><br><span class="line">  <span class="comment">// s.substr()</span></span><br><span class="line">  <span class="keyword">auto</span> show_reverse = [](<span class="type">const</span> vector&lt;string&gt; &amp;vs) &#123;</span><br><span class="line">    <span class="comment">// 这里用了auto 而不是auto &amp;，以保证遍历到的元素没有被修改.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : vs) &#123;</span><br><span class="line">      <span class="comment">// reverse 并不会修改vs中的元素</span></span><br><span class="line">      <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">show_reverse</span>(vs);</span><br><span class="line"></span><br><span class="line">  for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), [](<span class="type">const</span> string &amp;s) &#123;</span><br><span class="line">    <span class="comment">// 这里必须申请4个char空间，额外的一个留给编译器添加的\0</span></span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">reverse_copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), tmp);</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>颇有一种，茴字的四种写法的味道…</p>
</blockquote>
<p>但for_each还是比较有用的，如果你要对列表中的每个元素都执行特定的单一操作的话。  </p>
<blockquote>
<p>我们来复习一下python的lambda表达式，下例生成1-100的奇数和偶数，并将两者相加:</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">odd = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>))</span><br><span class="line">even = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x+<span class="number">1</span>, odd))</span><br><span class="line">rst = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x,y:x+y, odd, even))</span><br></pre></td></tr></table></figure>

<h3 id="lambda的值捕获与引用捕获"><a href="#lambda的值捕获与引用捕获" class="headerlink" title="lambda的值捕获与引用捕获"></a>lambda的值捕获与引用捕获</h3><p>在lambda表达式的捕获列表中，除了值传递，也可以通过&amp;完成引用传递。<br>对于值传递，lambda会在自己被定义时就完成拷贝，因此，后续对该值的更改不会影响到lambda。<br>值传递是const的，你无法修改，也不应该修改它的值。  </p>
<blockquote>
<p>当然，它可以被解const，以下是一个实例，同时也说明了lambda的值传递在定义时完成，而不是调用时。<br>也暗示了，lambda在创建一个自定义类型，而不是简单的函数调用的实质：它需要一块内存，保存值捕获的结果。  </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [tmp]&#123;</span><br><span class="line">    <span class="type">int</span> &amp;p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(tmp);</span><br><span class="line">    ++p;</span><br><span class="line">    cout&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">cout&lt;&lt;tmp;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// 102 </span></span><br><span class="line"><span class="comment">// 103</span></span><br><span class="line"><span class="comment">// 101</span></span><br><span class="line"><span class="comment">// 由于我们恶意地用const_cast解除了值捕获的read-only，因此，多次对lambda调用打印的捕获值有所不同。这暗示了lambda定义了一个类型，并将捕获到的值作为其const数据成员，在调用时产生对象。</span></span><br></pre></td></tr></table></figure>

<p>引用捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;size]&#123;<span class="keyword">return</span> size;&#125;;</span><br></pre></td></tr></table></figure>
<p>引用捕获的行为与一般引用一致。<br>在返回引用的对象上，lambda的规则与一般函数一致，不要返回局部对象的引用。离开作用域范围，会被回收。<br>引用捕获不进行值传递，如果引用的对象在lambda调用时已经被回收，那么调用就是危险的。<br>所以说，以引用方式捕获一个变量时，需要确保lambda执行时值依然存在。  </p>
<h3 id="lambda的隐式捕获"><a href="#lambda的隐式捕获" class="headerlink" title="lambda的隐式捕获"></a>lambda的隐式捕获</h3><blockquote>
<p>如果说有什么是最讨厌的，就是这一大堆令人费解，毫无可读性，让人摸不着头脑的省略写法。  </p>
</blockquote>
<p>隐式捕获指让编译器根据lambda中函数体的代码，推断需要捕获哪些变量。<br>在推断列表中写一个&#x3D;或&amp;，分别代表值捕获和引用捕获。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [=](<span class="type">const</span> string &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;=sz;&#125;)</span><br><span class="line"><span class="comment">// 由于写了=，sz会被推导，隐式捕获。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不过你问我会不会写？我肯定会写！挺方便的呀。</p>
</blockquote>
<p>可以混合使用隐式捕获和显式捕获，不过，若隐式捕获&amp;，则显式的只能是&#x3D;，相反亦然。  </p>
<h3 id="可变lambda-使得值捕获可变"><a href="#可变lambda-使得值捕获可变" class="headerlink" title="可变lambda:使得值捕获可变"></a>可变lambda:使得值捕获可变</h3><p>像之前说的，lambda的值捕获都会是const的，我们可以声明mutable，来使得它可变。<br>注意区分两种情况，mutable声明与引用捕获是截然不同的。mutable声明的值引用依然是值传递，使得捕获的参数可以改变，但是不会改变该参数的源对象，就像我们上面强制解const时的情况一样。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]()<span class="keyword">mutable</span>&#123;<span class="keyword">return</span> ++tmp;&#125;;<span class="comment">// 这种情况下不能省略参数的()，即使没有。</span></span><br><span class="line"><span class="comment">// 这有点让人在意，mutable不应该是作用在[]上的吗？</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 43 44</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda：无法推断返回值类型的情况"><a href="#lambda：无法推断返回值类型的情况" class="headerlink" title="lambda：无法推断返回值类型的情况"></a>lambda：无法推断返回值类型的情况</h3><p>有时候，lambda无法推断返回值的类型，此时需要显式指出：</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> i)&#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>)<span class="keyword">return</span> -i;<span class="keyword">else</span> <span class="keyword">return</span> i;&#125;;</span><br></pre></td></tr></table></figure>
<p>需要修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>)<span class="keyword">return</span> -i;<span class="keyword">else</span> <span class="keyword">return</span> i;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是primer说的，我在g++上，第一种情况也通过了。</p>
</blockquote>
<h3 id="使用bind生成新的可调用对象"><a href="#使用bind生成新的可调用对象" class="headerlink" title="使用bind生成新的可调用对象"></a>使用bind生成新的可调用对象</h3><blockquote>
<p>与python的functools.partial装饰器行为相似。  </p>
</blockquote>
<p>语法是auto new_callable &#x3D; bind(callable, arg_list)。arg_list中使用占位符，绑定部分参数。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newAdd = <span class="built_in">bind</span>(add, _1, _2, <span class="number">0</span>); <span class="comment">// 将第三个参数绑定为0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">newAdd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 输出3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TODO:</p>
<ul>
<li>10.4 再探迭代器</li>
<li>10.5 泛型算法结构</li>
<li>10.6 特定容器算法</li>
</ul>
<p>三节，感觉意义有限，暂时跳过。</p>
<h2 id="第十一章-关联容器"><a href="#第十一章-关联容器" class="headerlink" title="第十一章 关联容器"></a>第十一章 关联容器</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%99%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 教程</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 读书笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2024/07/13/WSL/" rel="next" title="WSL：Windows下的轻量linux系统">
                  WSL：Windows下的轻量linux系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lpdink</span>
</div>
  <div class="powered-by">感谢 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 提供博客支持！
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
